# 第四章 第四节 交互界面

提醒：脚本中可能含有思考题与实践题

## js中的事件响应

随着codelab的学习，我们已经学了不少东西，在上一节我们学习了UI绘制，但造塔中作者绘制一个UI往往不只是用来看的，我们常常希望玩家去使用这个UI进行作者期望的行为，比如说技能加点，需要玩家去点击UI达成加点操作。为了解决这个问题，我们可以通过给我们的元素添加点击事件解决：

```html
<button onclick="alert('2333')">按钮</button>
<a href="javascript:alert('2333')">超链接</a>
```

```javascript
myCanvas.onclick = function(e) {
    alert("x:" + e.clientX + ",y:" + e.clientY);
}
```

按键监听事件：`onkeydown`：按下键盘按键时触发的事件。`onkeyup`：按下的按键弹起时触发的事件等。传入的参数e是一个event对象，根据事件的不同，event也不同，比如说如果是鼠标事件将传入mouseEvent，如果是键盘事件将传入keyboardEvent等等（<https://developer.mozilla.org/zh-CN/docs/Web/API/Event>），同时mouseEvent和keyboardEvent将继承event对象上的方法，如`event.stopPropagation()`。

我们的元素不是仅能添加这一个事件，实际上有数十种事件可以添加，详见：<https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalEventHandlers>，我们先解释下几个造塔中常用的,首先是点击时触发的三个鼠标事件

* `onmousedown`:鼠标按下时的事件；
* `onmouseup`:放开鼠标按键时执行的事件；

* `onclick`：click事件在点击时触发，在onmousedown和onmouseup事件执行后执行。
* 此外的mouseEvent还有，`onmouseover`：鼠标移动到某个元素上触发的事件。`ondblclick`：鼠标双击时触发的事件。

当我们准备点击时，先把鼠标移动到要点击的点，触发了n次mouseover之后按下鼠标左（右）键，触发被点击到的所有元素的mousedown事件，然后鼠标弹起，触发mouseup，点击行为完成，触发click。

我们知道，手机上是没有鼠标的。可以使用touch事件代替（<https://developer.mozilla.org/zh-CN/docs/Web/API/TouchEvent>），样板中统一处理了touch和mouse的情况，将它们均视为ondown/onup，这也是使用样板api的一个优势。

样板使用这一方法处理用户交互的过程中，样板画布中的data层负责接收点击坐标，并计算出当前点击的坐标在游戏界面中的位置。

```javascript
////// 鼠标按下时 //////
main.dom.data.onmousedown = function (e) {
    try {
        e.stopPropagation(); // 停止冒泡 在下面会讲
        var loc = main.core.actions._getClickLoc(e.clientX, e.clientY);
        // 思考：clientX,clientY、offsetX,offsetY、movementX,movementY有什么差别？请查阅mdn文档后回答
        if (loc == null) return;
        // 实践：如果把元素旋转90度，应当如何处理点击坐标才能使点击正常？
        main.core.ondown(loc);
    } catch (ee) { console.error(ee) }
}
////// 在界面上按下某按键时 //////
main.dom.body.onkeydown = function (e) {
    // 思考：keycode有什么缺点，以至于新的DOM标准中将其弃用，改为key？以及key有什么优点？请查阅mdn文档后回答
    try {
        if (main.dom.inputDiv.style.display == 'block') return;
        if (main.core && (main.core.isPlaying() || main.core.status.lockControl))
            main.core.onkeyDown(e);
    } catch (ee) { console.error(ee) }
}
```

我们还有一个更好的办法：`addEventListener`代替onclick这种写法。上面的样例可以改写成：

```javascript
myCanvas.addEventListener("click", function(e) {
    alert("x:" + e.clientX + ",y:" + e.clientY);
});
myCanvas.addEventListener("click", function(e) {
    alert("第二次触发");
});
```

使用addEventListener可以同时对一个元素使用多次，会按顺序依次运行。addEventListener的详细语法见<https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener>。

> 实践：制作一个可以拖动的元素。

#### 拓展内容：事件冒泡与事件捕获

addEventListener的另一个优势是可以选择事件冒泡或事件捕获。在这之前我们先解释一下这两个词的意思。

虽然我们说了很多事件，但是说到底什么是事件？这里的事件不同于样板内的事件，指的是当前页面中一个有意义的时刻，比如说在哪里点了鼠标，或者按了什么按键，事件流则是页面决定接受事件的顺序，而冒泡和捕获是两种事件流的模型。

事件冒泡是一种由内及外的顺序执行事件的过程，我们知道元素之间存在着上下级的关系，比如说样板的画布都是一个叫gameDraw的元素的子节点，gameDraw又包含在gameGroup内（不清楚的人可以打开控制台，从gameGroup一直往下找，直到找到我们熟悉的各个canvas），如果我们点击游戏界面，鼠标事件正常的传递顺序应该是从 data=>gameDraw=>gameGroup 。以下为例：

```javascript
core.dom.data.onmousedown = (e) => console.log(114);
core.dom.gameDraw.onmousedown = (e) => console.log(514);
core.dom.data.onmouseup = (e) => console.log(1919);
core.dom.gameDraw.onclick = (e) => console.log(810);
/* 点击游戏界面，输出为：
114
514
1919
810
*/
core.dom.data.onmousedown = (e) => {
    e.stopPropagation();// 我们之前提过的阻止冒泡的一种方法
    console.log(114);
}
/* 再次点击游戏界面，输出为：
114
1919
810
*/
```

从上面的例子我们可以注意到两个事情，一个是没有输出514，因为阻止冒泡后，事件在子元素data上就被阻止了，没有冒泡到gameDraw上，gameDraw的onmousedown事件没有触发。另一个是gameDraw的onclick事件正常执行，输出了810，虽然我们常识里鼠标的点击就是一个整体的行为，但是鼠标事件就像我们之前说的一样是分成多个阶段的，阻止了onmousedown事件冒泡不会影响onclick事件触发。

事件捕获则是另一种与事件冒泡正好相反的东西，事件从父元素开始，向内捕获子元素的事件，是由外及内的传递过程，同样的例子，这回传递的顺序将是gameGroup=>gameDraw=>data。我们可以通过使用addEventListener的第三个参数指定事件的传递顺序是冒泡还是捕获。

```javascript
core.dom.data.addEventListener("mousedown", (e) => {
    console.log(114);
}, true);// 把addEventListener的第三个参数设置成true或者{ capture:true }，mousedown事件触发的顺序将会变成事件捕获的顺序
core.dom.gameDraw.addEventListener("mousedown", (e) => {
    console.log(514);
}, true);
core.dom.data.addEventListener("mouseup", (e) => {
    console.log(1919);
}, true);
core.dom.gameDraw.addEventListener("click", (e) => {
    console.log(810);
}, true);
/* 点击游戏界面，输出为：
514
114
1919
810
可以看出，114和514的输出顺序颠倒了
*/
```

我们发现，gameDraw先于子元素data输出了514，同时click事件仍然晚于mouseup，输出仍是1919810。

## 样板中的用户交互

样板中有两种封装好的实现事件交互的办法，简单的办法是使用等待用户交互事件，这个办法门槛比较低，而且天然支持录像，是入门的好选择，但是也存在局限，首先编辑起来不够简明清晰，其次事件执行过程中进行了`core.lockControl()`，此时我们操纵的角色既不能移动，也不能打开背包等。更灵活的方式是使用`core.actions.registerAction`这个api。事件流处理用户交互的用法在文档中有提到，这里我们只讲registerAction。

```javascript
//////  注册一个用户交互行为 //////
/*
 * 此函数将注册一个用户交互行为。
 * action：要注册的交互类型，如 ondown, onup, keyDown 等等。
 * name：你的自定义名称，可被注销使用；同名重复注册将后者覆盖前者。
 * func：执行函数。
 * priority：优先级；优先级高的将会被执行。此项可不填，默认为0。
 * 返回：如果func返回true，则不会再继续执行其他的交互函数；否则会继续执行其他的交互函数。
 */
actions.prototype.registerAction = function (action, name, func, priority) {
    if (!name || !func)
        return;
    // 将onclick视为ondown处理
    if (action == 'onclick') action = 'ondown';
    priority = priority || 0;
    if (!this.actions[action]) {
        this.actions[action] = [];
    }
    this.unregisterAction(action, name);
    this.actions[action].push(
        { "action": action, "name": name, "func": func, "priority": priority }
    );
    this.actions[action] = this.actions[action].sort(function (a, b) {
        return b.priority - a.priority;
    });
}
```

registerAction上最重要的参数毫无疑问就是func，也就是点击时触发的行为，根据行为的不同会传入不同的参数，比如说：

```javascript
actions.prototype.ondown = function (loc) {
    var x = parseInt(loc.x / loc.size), y = parseInt(loc.y / loc.size);
    var px = parseInt(loc.x / core.domStyle.scale), py = parseInt(loc.y / core.domStyle.scale);
    this.doRegisteredAction('ondown', x, y, px, py); // ondown中传入的参数是x y px py 分别是格子坐标和像素坐标
}
// 使用样例：
core.registerAction("ondown", "log", function(x, y, px, py) {
    // 点击的坐标 如果是onmove(对应onmouseover) 就将是鼠标指针移动到的当前坐标
    console.log("x:" + x, "y:" + y);
    console.log("px:" + px, "py:" + py);
    return true;// return true会中断优先级更低的action的执行 起到类似阻止事件冒泡的作用
});
// keycode是映射按键的一组数字，比如说如果你按下A keycode的值就会被设为65 具体的对照表网上有很多
core.registerAction("keydown", "log", function(keycode) {
    console.log("key:" + keycode);
});
```

优先级priority决定同样的action类型中哪个先被执行，我们观察一下actions.js中已经注册好的action

```javascript
this.registerAction('keyUp', '_sys_keyUp_replay', this._sys_keyUp_replay, 100);
this.registerAction('keyUp', '_sys_keyUp_lockControl', this._sys_keyUp_lockControl, 50);
this.registerAction('keyUp', '_sys_keyUp', this._sys_keyUp, 0);
```

从函数名上我们就可以猜想，优先级高达100的`_sys_keyup_eplay`函数大概率跟录像回放有关，lockControl往往跟各种系统事件联系在一起。实际上也是如此，如果`_sys_keyUp_replay`检测到当前正在进行录像回放，就会return true阻止事件冒泡，如果说你想你注册的action在录像执行的时候也可以使用，就需要把priority设置为大于100， 同理`_sys_keyUp_lockControl`与各种系统事件执行时的交互有关，比如说显示文本事件时清除对话框，打开手册时的换页和退出等都有关，同时也会return true阻止事件继续向低优先级执行。

最后要注意一个重要的点就是录像问题，简单来说录像系统就是把用户进行的所有的有效行为都记录下来并从最初的行为开始重新跑一遍以验证用户是否有作弊行为和方便用户进行路线调整的系统，我们自己注册的ui的交互过程中往往需要告知录像系统（如果是不影响游戏内容的行为反过来什么都不告知更好，这个时候使用事件流会自动记录点击行为，遇到了实际上没有执行的录像行为就会出错，这时反而要删掉这些行为才能跑通录像。）常用的告知录像系统的办法是`core.status.route.push("key:xx")`，或者`registerReplayAction`，在录像系统的学习中我们会更深入探讨这个问题。（真的有吗？

至此，基本上造塔过程中常用的用户交互我们已经介绍的差不多了，可以尝试去看样板中注册好的事件或者自己动手开写了，最后这点交内容算是丰富例子（其实是凑上节的数），基本上学下来一眼就能看懂是啥意思了。

```javascript
////// 楼层传送器界面时的点击操作 //////
actions.prototype._clickFly = function (x, y) {
    if ((x == this.SIZE - 2 || x == this.SIZE - 3) && y == this.HSIZE + 3) { core.playSound('光标移动'); core.ui.drawFly(this._getNextFlyFloor(-1)); }
    if ((x == this.SIZE - 2 || x == this.SIZE - 3) && y == this.HSIZE - 1) { core.playSound('光标移动'); core.ui.drawFly(this._getNextFlyFloor(1)); }
    if ((x == this.SIZE - 2 || x == this.SIZE - 3) && y == this.HSIZE + 4) { core.playSound('光标移动'); core.ui.drawFly(this._getNextFlyFloor(-10)); }
    if ((x == this.SIZE - 2 || x == this.SIZE - 3) && y == this.HSIZE - 2) { core.playSound('光标移动'); core.ui.drawFly(this._getNextFlyFloor(10)); }
    if (x >= this.HSIZE - 1 && x <= this.HSIZE + 1 && y == this.LAST) { core.playSound('取消'); core.ui.closePanel(); }
    if (x >= 0 && x <= this.HSIZE + 3 && y >= 3 && y <= this.LAST - 1)
        core.flyTo(core.floorIds[core.status.event.data]);
    return;
}

////// 楼层传送器界面时，按下某个键的操作 //////
actions.prototype._keyDownFly = function (keycode) {
    if (keycode == 37) { core.playSound('光标移动'); core.ui.drawFly(this._getNextFlyFloor(-10)); }
    else if (keycode == 38) { core.playSound('光标移动'); core.ui.drawFly(this._getNextFlyFloor(1)); }
    else if (keycode == 39) { core.playSound('光标移动'); core.ui.drawFly(this._getNextFlyFloor(10)); }
    else if (keycode == 40) { core.playSound('光标移动'); core.ui.drawFly(this._getNextFlyFloor(-1)); }
    return;
}
```

> 实践（高难提醒）：使用canvas及样板的api制作一个可以编辑多边形的编辑工具

> 实践：重构楼传界面，不做具体要求，能用就行