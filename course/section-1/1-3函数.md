# 第一章 第三节 函数

在本节中，你将学会函数的基本使用

## 函数的概念

我们在数学课上都学过函数，在数学课上，函数被认为是一种对应关系，例如说，对于`f(x) = x`（很明显这是个一次函数），有 `f(1) = 1`，`f(2) = 2`。

## 声明函数

我们可以在 js 中表达出上面描述的这个函数，像这样：

```js
function f(x) {
    return x;
}
console.log(f(1)) // 1
```

对照这个例子，我们可以大概理解其语法。详细的解释如下：

```js
function 函数名称(自变量) {
    // 函数体
    // return 的值即是函数映射到的结果
}
```

在 js 以及其他现代编程语言中，我们将自变量称为 `参数`，映射到的结果称为 `返回值`。

也许你已经注意到，函数体是由花括号包裹的，这意味着你可以在函数体内编写任意多的语句，就像在循环里做的那样，例如说，以下是`f(x) = |x|`的 js 实现：

```js
function f(x) {
    if (x < 0) return -x;
    return x;
}
console.log(f(1)) // 1
console.log(f(-1)) // 1
```

在这个例子中，不难发现，对于 `x < 0` 的情况会执行 `return -x;` 语句，随后得到的返回值也符合这个语句的内容，那么`return x` 呢？事实上，和循环中的 `break` 类似，一旦执行 `return` 语句，函数就会终止执行并立即返回。

实际上，函数的参数可以不只有一个，你可以这么写：

```js
function lessThan(x, y) {
    if (x < y) return true;
    return false;
}
console.log(lessThan(1, 2)) // true
```

## 参数进阶

如果我们向函数中传入的参数数量和声明时写的数量不同，会发生什么情况？我们可以一试：

```js
function f(x) {
    return x;
}
console.log(f()); // undefined
```

实际上，如果传入的参数（称为实际参数），比声明时写的参数（称为形式参数）少，剩下的参数会被填充为 `undefined`。如果实际参数多于形式参数，则程序一切正常，无事发生。
 
## 函数的副作用

我们在上面介绍了数学函数在 js 中的实现，不过，在 js 中，函数的能力不止于此，你可以在函数中读取或者修改外部的变量，像这样：

```js
var i = 0;
function add(val) {
    i += val;
    return i;
}
```

这种能力被称为 `副作用`（相对的，没有副作用的函数被称为纯函数），例如说，我们在样板中调用的 `core.win()` 等函数都是主要以副作用形式起效的。当一个函数只有副作用的时候，甚至可以没有参数或者返回语句。特别的，当函数没有返回语句时，返回值为 `undefined`。

```js
var i = 0, j = 0;
function print() {
    console.log(i, j);
}
print(); // 0 0
i = 1
print(); // 1 0
console.log(print()) // 1 0  undefined 
```

## 编程风格：子程序与纯函数

在早期的一些语言中，类似函数的功能被叫做 `procedure`（子程序 / 过程），这些语言中函数更多的依赖于副作用。它们相当于一个可以随便嵌入的代码片段。另外一些人则相信副作用会使得程序难以维护，因为变量可能在你不知情的情况下被随意改变，实际上，参数这个设计就是这一思路下的想法，注意到如果你调用函数时传入的参数是变量，在内部改变这个对应的参数是没有效果的，因为内部使用的参数并不是原本的变量，而是复制的结果。

```js
function add(i) {
    i += 1;
}
var i = 0;
add(i);
console.log(i); //0
```

可以像这样理解上面函数的实际效果：

```js
var i = 0;
{
    var _i = i;
    _i += 1;
}
console.log(i); //0
```

如今主流的编程会要求一定程度上控制副作用，但是不像纯函数派那么严格。

## 一等公民函数

与其他一些编程语言不同，在 js 中，函数是一种特别的变量，因此你可以将函数存储在变量中，像这样：

```js
var add = function add2(i) {
    return i + 2;
}
console.log(add(5)); // 7
add = function add3(i) {
    return i + 3;
}
console.log(add(5)); // 8
```

在这种情况下，你甚至可以不声明函数的名称，就像这样：

```js
var add = function (i) {
    return i + 2;
}
```

实际上，也有人使用这种方法定义函数，不过，这种方法和直接使用 `fucntion` 语句在效果上有微妙的区别，像这样：

```js
add1(1); // 2
add2(1); // Uncaught TypeError: add2 is not a function
function add1(i) {
    return i + 1;
}
var add2 = function (i) {
    return i + 2;
}
```

我们看到调用 `add2` 函数会报错。这是因为它在被赋值前就被调用了，此时它还不是函数。
