# 第一章 第三节 函数

在本节中，你将学会函数的基本使用

## 一 声明函数

### 什么是函数

我们先看一下数学上的函数什么意思。在数学上，函数是一种对应关系，例如`f(x) = x`就是一个一次函数，我们令`y = f(x)`，那么，我们输入`x`，就会得到一个`y`的值，这是数学上的一般函数，由输入值可以算出一个的值

下面我们再看程序上的函数，首先第一点不一样就是自变量，在程序里称为参数，这里的函数可以没有，有一个，甚至有100个参数。但是，在没有外部干扰的情况下，输入相同的参数，得到的结果一定是固定的。我们可以用榨汁机类比一下函数

我们将榨汁机看做一个函数，水果是自变量，输出的果汁是返回值（也就是数学上的函数值），那么，我们放进去一个苹果，就会榨出来苹果汁，放进去梨，就会榨出来梨汁。也就是说，我们放进去一个水果，函数通过一定的操作以后，会返回一个汁出来。那么如果我们将苹果和梨都放进去呢？当然会输出梨和苹果的混合汁。这样来看，函数的参数数量是不唯一的。因此，程序里的函数就是广义的数学函数，用于多次执行一个重复的代码块

### 函数的两种声明方法

在js中，我们有两种常用的函数声明方法，下面我们一一进行讲解

#### function声明

我们一般用这种方式进行函数声明，格式如下

```js
function name (...params) { code; }
```

我们分析一下。首先，`function`是声明函数的意思，`name`是函数名，之后有一个圆括号，圆括号里面是函数的参数，之后是一个代码块（不能是一条语句，也就是说，声明函数时没有像if那样的缩写形式），里面跟着要执行的代码

我们简单进行一下示范

```js
function myFunc (x, y, z) {
    console.log(x, y, z);
}
```

这里，我们声明了一个`myFunc`函数，有`x` `y` `z`三个参数，之后的代码块中，我们又将这三个参数输出

#### var声明

这是函数声明的第二种方式格式如下

```js
var myFunc = function (...params) { code; }
```

这种声明方式的效果和上面那种差别不大，这里不再演示

下面我们要说一下这两种声明方式的差别

#### function vs var

我们只说最主要的差别，那就是调用位置不同。用`function`声明的函数可以在声明之前调用（`f()`是调用函数f的意思，下面将要会讲到），例如

```js
f();
function f () { console.log(1); }
```

这样完全没有问题，会正常输出1。而与之对比，var如果这样的话

```js
f()
var f = function () { console.log(1); }
```

会抛出一个类型错误`Uncaught TypeError: f is not a function`，也就是说，用var声明的函数不可以在声明前使用

## 二 函数的调用

既然我们声明了函数，那么我们就要调用函数，一般来讲，调用函数用`func()`的形式调用。（还有另一种调用方式，这里不再提及，几乎用不到）

```js
function myFunc () {
    console.log('hello function');
}

// 调用函数
myFunc();
// 当然一个函数可以调用多次
myFunc();
myFunc();
// 当然也可以用循环
for (var i = 0; i < 10; i++) myFunc();
// 也可以用第二节中讲的while
while (myFunc());
```

这样我们就实现了函数的调用

## 三 函数的参数

之前我们提到了函数有参数，下面我们要细讲。

函数的参数有两种——`实参`和`形参`

### 形参

在定义函数时声明的参数称为形参

```js
function myFunc (x, y, z) { // 这里的x, y, z称为形参

}
```

#### 形参的使用

既然我们声明了形参，我们就要使用它

```js
function myFunc (x, y, z) { console.log(x + y + z); }
```

这就是一个将`xyz`加起来输出到控制台的程序。这里在括号里面声明的`xyz`可以直接拿来使用，相当于`var`声明的变量。

### 实参

在调用函数时传入的参数成为实参

```js
myFunc(1, 2, 3); // 这个1 2 3就是实参
```

这样，我们就可以将实参`1 2 3`传给形参`xyz`，然后执行函数内的程序，在控制台输出6

### 用数学类比形参和实参

在这里我们可能不好理解形参和实参的转化关系，我们可以用数学上的函数类比一下

例如我们令`f(x) = x² + 4x - 5`，那么这个`x`就可以认为是形参，这时候我们传入`1`，那么就会得到`f(1) = 1² + 4 * 1 - 5 = 0`这时候，这个`1`就是实参，被形参`x`接收以后传入到函数`x² + 4x - 5`中，得到结果`0`，而这个结果`0`就是我们下面要讲到的返回值

## 四 函数的返回值

与数学上类似，每个函数在输入一个自变量以后都会有一个与之对应的函数值（不要说什么定义域，这里不考虑这个东西），js中，每个函数都有返回值。具体写法是`return 要返回的内容`

### 返回值的使用

我们直接看例子

```js
function f (x, y, z) { return x + y + z; }
```

上面这个函数就定义了一个函数，函数的返回值是形参`xyz`的和

### 接收返回值

和数学上一样，有了函数值以后，我们要用一个量把它存储起来，这里我们可以直接使用变量将返回值存储起来

```js
var res = f(1, 2, 3);
```

这样，我们就用`res`将函数`f`返回的函数值存储了起来，这时候，我们输出`res`，就会显示6

### 返回值的注意事项

1. 执行返回会让函数立刻停止运行，之后的代码均不会执行
2. 返回值是唯一的，一个return只能返回一个返回值
3. 可以通过`return statement1, statement2, ...`的形式在`return`的同时执行多条语句，但只会返回最后一个表达式的结果
4. 一个函数可以没有`return`，这时函数的返回值为`undefined`

## 五 arguments

有的时候，我们不知道实参会传入多少个，这时候，如果我们写很多形参的话，就会显得很啰嗦。因此，js提供了一个工具——`arguments`，它会将所有传入的实参储存起来。具体用法如下

```js
function func () {
    var a = arguments[0];
    var b = arguments[1];
    return a + b;
}
func(1, 2);
```

可以看到，我们将`arguments[0]`赋给了`a`，将`arguments[1]`赋给了`b`。在函数内，`arguments[0]`代表第一个参数，`arguments[1]`代表第二个参数...以此类推

## 六 递归

在函数内部调用自身被称为递归

```js
function func () {
    console.log(1);
    func();
}
func();
```

这就是一个典型的递归的例子。不过如果这样执行，它会死循环吗？不，下面我们就来看一下会发生什么

### 递归过多——爆栈

如果你执行上述代码的话，最后会得到一个报错`Uncaught RangeError: Maximum call stack size exceeded`，这里我们不必深究其原因，只要知道它代表递归次数过多，出现的报错即可。不同设备的可递归次数不一定相同，所以在程序中尽量不要有大剂量的递归 :)

### 正常递归的例子——斐波那契数列

斐波那契数列是指 1 1 2 3 5 8 13 21 ... 即第`n`项是第`n-1`和`n-2`项的和，下面我们就用递归来实现计算第n项

```js
function cal (n) {
    if (n - 3 < 0) return 1; // n为 1 或 2 时输出1
    return cal(n - 1) + cal(n - 2); // 否则输出前两项的和
}
// 这时我们可以调用cal(n)来计算出第n项的结果
cal(3); // 2
cal(5); // 5
cal(7); // 13
```

这就是递归的正确用法，必须要有条件来终止函数继续递归，否则会爆栈。如果看不懂上面那个例子，可以仔细想一想