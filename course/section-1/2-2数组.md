# 第二章 第二节 数组

在本节中，你将学会js中一种常用数据——数组的使用

## 一 什么是数组

顾名思义，数组就是存储了一组数据的东西

### 声明数组

声明数组我们用var

```js
var arr = [1, 'array', true, [1, 4, '1234567890']];
```

我们可以看到，在数组里面我们可以存储任何数据类型的内容，因此，在存储一系列有序内容的时候，数组是一个很好的选择

## 二 操作数组

当然，我们不能只在定义数组的时候向数组内存储数据，我们需要操作数组

### 获取数组的某一项

我们可以用`array[n]`的形式获取数组的某一项

```js
var arr = [1, 2, 3, 4, 5];
arr[0]; // 1
arr[3]; // 4
```

注意，0是指第一项，1是指第二项...以此类推。这里的`n`被称作索引

### 改变数组的某一项

```js
arr[0] = 9;
arr; // [9, 2, 3, 4, 5]
```

没错，直接`array[n] = xxx`即可改变数组的某一项

## 三 回调函数及高级函数

在js中，可以在调用函数时传入一个函数作为实参，这个函数就称为回调函数。

```js
setTimeout(function () { console.log(111); }, 1000);
```

上面这个例子中，`function () { console.log(111);`就称为回调函数。（上面这个例子是延迟1000ms执行输出111）

### 回调函数的参数

回调函数也可以有形参，实参由被调用的函数本身提供，例如

```js
function myFunc (callback) {
    var x = 10;
    callback(x); // 这里的x是回调函数的实参
}

myFunc(function (x) { console.log(x * 10); }); // 这里的x是回调函数的形参
```

在上面这个例子中，我们在调用函数`myFunc`时，传入了一个回调参数，拥有一个形参x，然后程序会执行函数`myFunc`的内容，声明变量`x`为`10`，然后将`x`作为实参传入回调函数中，回调函数的形参`x`接受传入的实参`x`，输出`x * 10`

### 高级函数

高级函数指返回函数的函数

```js
function myFunc(x) {
    return function (y) {
        return x + y;
    }
}
myFunc(1)(2); // 因为myFunc的返回值为一个函数，所以我们在调用过一次以后可以立即再次调用，便出现了两个()
```

我们来解析一下上面的内容

首先，程序执行时，首先执行`myFunc(1)`，这样将会得到一个返回值，返回值为另一个函数，这时候相当于`myFunc(1)`变成了一个函数，又可以通过`(2)`来调用，就出现了两个`()`，于是在执行之后便会返回`1+2`，结果为3

## 四 遍历数组

我们经常会用到遍历数组的情况。这里我们一共有四种方法

### 方法一 for of

我们在遍历时的首选方法就是`for of`

> 该方法为ECMAScript6中规定的用法，在造塔时不可使用

```js
var arr = [1, 8, 9, 4, 0];
for (var ele of arr) {
    console.log(ele);
}
```

这样，我们可以输出数组中所有的元素。这里在`for循环`中写的`var ele of arr`，意思为`令ele为arr中的元素`，也就是说，ele为1 8 9 4 0，这样以此遍历

### 方法二 forEach

数组本身有一个方法为`forEach`，该方法一般是二选方法，相比于`for of`的优点是可以获得正在遍历项的索引

方法的用法：`Array.forEach((value, index?, thisArr?) => void, context?)`，可能看不懂，我们举例子解释

```js
var arr = [1, 2, 6, 3, 9];
arr.forEach(function (v, i, a) {
    console.log(v); // 输出正在遍历项的值
    console.log(i); // 输出正在遍历项的索引
    console.log(a); // 输出正在遍历的数组
});
```

可以看到，方法第一个参数是一个回调函数，包含3个形参，第一个是正在遍历项的值，第二个是正在遍历项的索引，第三个是当前数组。方法的第二个参数为函数执行时的上下文，现在不必做了解

### 方法三 for in

第三方法是`for in`，也是一个常用的方法

```js
var arr = [1, 2, 3, 4, 5];
for (var i in arr) {
    console.log(arr[i]);
}
```

在`for`中我们声明的变量`i`是索引，这是与`for of`的唯一一点不同

### 方法四 for

这个方法很少用到，但是它有个别人都没有的优点——可以更改在for里var的变量

```js
var arr = [1, 2, 3, 4, 5];
var t = 0;
for (var i = 0; i < arr.length; i++) { // arr.length 数组的长度
    console.log(arr[i]);
    if (t === 0 && i === 3) i = 0, t++; // 在 t === 0 且 i === 3 时将i赋值为1，同时t变成1，实现遍历回退的效果
}
```

这个方法主要用于需要删减或增添数组内的内容的情况

## 五 数组方法

这一部分内容较多，请认真看书，仔细思考

### push

在数组最后添加新的项，用法：`Array.push(...items)`

```js
var arr = [];
arr.push(1, 3, 5);
arr; // [1, 3, 5]
```

### pop

删除数组的最后一项，用法：`Array.pop()`，返回值为删除的项

```js
var arr = [1, 2, 3];
var last = arr.pop();
arr; // [1, 2]
last; // 3
```

### shift

删除数组的第一项，并返回，用法：`Array.shift()`

```js
var arr = [1, 2, 3];
var first = arr.shift();
arr; // [2, 3]
first; // 1
```

### unshift

像数组开头添加项，用法：`Array.unshift(...items)`

```js
var arr = [1, 2];
arr.unshift(1, 4, 3);
arr; // [1, 4, 3, 1, 2]
```

### reverse

颠倒原数组，用法：`Array.reverse()`

```js
var arr = [1, 2, 3, 4];
arr.reverse();
arr; // [4, 3, 2, 1]
```

### toString

每个数据类型都有这个方法（除了string），不用演示了

### join

向数组内的每一项中间插入某个字符后拼接成字符串，用法：`Array.join(text)`

```js
var arr = [1, 2, 3, 4];
var text = arr.join('<');
text; // '1<2<3<4'
```

### concat

连接两个数组，不修改原数组，返回连接后的数组，用法：`Array.concat(arr)`

```js
var arr1 = [1, 2];
var arr2 = [3, 4];
var res = arr1.concat(arr2);
res; // [1, 2, 3, 4]
```

### indexOf

查找对应项在数组内的索引，找不到则返回-1，为强等于（注意数组和对象不能用强等于判断是否相等），用法：`Array.indexOf(item, fromIndex?)`，第二个参数为开始搜索的索引

```js
var arr = [1, 2, 3, 2, 1];
arr.indexOf(1); // 0
arr.indexOf(1, 2); // 4
arr.indexOf(4); // -1
```

### lastIndexOf

从右往左搜，返回索引，找不到返回-1，参数和`indexOf`相同

### includes

查找数组内是否有某个元素，有则返回true，否则返回false，参数和`indexOf`相同

### splice

删除数组内的项，会改变原数组，用法：`Array.splice(start, deleteCount?, ...items)`

第一个参数为开始删除的索引，填负数视为从右向左数的索引，第二个为删除数量，不填则将之后的全部删除，之后的参数要添加进数组的元素，从`start`位置开始。如果不指定，则`splice()`将只删除数组元素

```js
var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0];
arr.splice(6);
arr; // [1, 2, 3, 4, 5, 6];
arr.splice(3, 1, 5, 6, 7);
arr; // [1, 2, 3, 5, 6, 7, 4, 5, 6]
```

从这开始稍微有点难度了，认真思考一下

### slice

提取源数组的一部分并返回一个新数组，不修改原数组，用法：`Array.slice(start?, end?)`

第一个参数为开始提取的索引，不填视为0，填负数视为从右向左数，第二个同理

```js
var arr = [1, 2, 3, 4, 5];
var s = arr.slice(1, 2);
s; // [2, 3]
arr; // [1, 2, 3, 4, 5] 不修改原数组
```

### fill

用一个固定值填充一个数组中从起始索引到终止索引内的全部元素，用法：`Array.fill(value, start?, end?)`

第一个参数为要填充的内容，第二个和第三个参数与`slice`的第一个和第二个参数含义相同

### at

返回数组对应索引位置的值，如果为负数则视为从右往左数，用法：`Array.at(index)`

> 该方法兼容性较差，不建议使用

### ------------------------ 低级高级方法分界线 ------------------------

以下内容均为参数带有回调函数的方法，难度较大，请认真思考

### some

检测数组中是否有元素符合条件，如果是空数组，则返回`false`，用法：`Array.some((value, index?, array?) => boolean, thisArg?)`

我们先对类型标注做一下科普，比如这里的回调函数，`(value, index?, array?)`表示回调函数的参数，?表示可选，后面的`boolean`表示该回调函数的返回值类型，没有返回值则为`void`

第二个参数照样不用管，之后的也都不用管，目前用不到

```js
var arr = [1, 2, 3, 4, 5];
arr.some(function (v) { return v > 4; }); // 返回true，因为数组内有一项 5 大于4
arr.some(function (v, i) { return i < 3 && v > 4 }); // 返回false，因为前三项中没有大于4的项
```

### every

和`some`类似，该方法检测是否所有元素都满足条件

> 从下面开始难度会飙升，请更加认真地阅读，并仔细思考

### filter

创建一个新数组, 其包含通过所提供函数实现的测试的所有元素，用法：`Array.filter((value, index?, array?) => boolean, thisArg?)`

```js
var arr = [1, 21, 31, 48, 5, 633, 7, 111, 3];
var filtered = arr.filter(function (v, i) { return i > 2 && v < 10; });
filtered; // [5, 7, 3]
```

### find

搜索数组内的元素，找到第一个对应项，并返回这个对应项，找不到则返回`undefined`，用法：`Array.find((value, index?, array?) => boolean, thisArg?)`

```js
var arr = [1, 2, 3, 2, 1];
var res = arr.find(function (v, i) { return i > 1 && v < 3; });
res; // 返回2，因为2是第一个满足条件的项
```

### findIndex

和`find`一样，只不过变成了返回对应项的索引，找不到则返回-1

### map

返回一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值，用法：`Array.map((value, index?, array?) => any, thisArg?`

```js
var arr = [1, 2, 3, 4, 5];
var res = arr.map(function (v, i) { return v * i; });
res; // [0, 2, 6, 12, 20]
```

### sort

数组初学者的噩梦...

对数组元素进行原地排序并返回此数组，会修改原数组，回调函数可选，用法：`Array.sort(((a, b) => number)?)`

a b为正在比较的元素

如果回调函数不填，则按首字母排序，如果填写回调函数，就有意思了，如果返回值为负，那么a将会排在b之前，如果返回值为0，则a b的位置不变，如果返回正数，则b会排在a之前

```js
var arr = [12, 3829, 120, 2783, 123, 902];
arr.sort(); // [12, 120, 123, 2783, 3829, 902] 这是按照首字母排序
arr.sort(function (a, b) { return a - b; }); // 升序排序
arr.sort(function (a, b) { return b - a; }); // 降序排序
// 当然也可以有更骚的操作
var arr2 = [[1, 2], [1, 3], [4, 5]];
arr2.sort(function (a, b) { return a[0] - b[0]; }); // 按数组第一项升序排序
var arr3 = [[1, 2], [4, 1], [8, 3]];
var arr4 = [131, 43, 123, 5334, 124, 5443, 234, 5346, 8432, 1234];
arr3.sort(function (a, b) { return arr4[a[0]] - arr4[b[0]]; }); // 按照数组第一项对应的arr4数组的项进行排列
```

### ------------------------ 以下内容选修，看不懂就算了 ------------------------

### reduce

第二个噩梦...比`sort`更难。看不懂就算了，`for of`完全可以替代

对数组中的每个元素执行一个由您提供的reducer函数（从左到右执行），将其结果汇总为单个返回值，用法：`Array.reduce((accumulator, currentValue, index?, array?) => any, initialValue?)`

参数说明：

callback
执行数组中每个值 (如果没有提供`initialValue`则第一个值除外)的函数，包含四个参数：

&nbsp;&nbsp;&nbsp;&nbsp;`accumulator`
累计器累计回调的返回值; 它是上一次调用回调时返回的累积值，或initialValue（见于下方）。

&nbsp;&nbsp;&nbsp;&nbsp;`currentValue`
数组中正在处理的元素。

&nbsp;&nbsp;&nbsp;&nbsp;`index` `可选`
数组中正在处理的当前元素的索引。 

如果提供了initialValue，则起始索引号为0，否则从索引1起始。

&nbsp;&nbsp;&nbsp;&nbsp;`array` `可选`
调用`reduce()`的数组

`initialValue` `可选`
作为第一次调用`callback`函数时的第一个参数的值。 

如果没有提供初始值，则将使用数组中的第一个元素。

在没有初始值的空数组上调用 `reduce`将报错。

（这次是直接把MDN的给抄过来了，因为真的很难解释）

```js
var arr = [92, 120, 237, 1298];
// 我们要求它的和不必用循环，可以用reduce
var res = arr.reduce(function (acc, curr) { return acc + curr; });
// 这里的acc是之前的计算所累计的和，curr是当前项的数据
// 当然这个也可以处理字符串，并执行一些其它的函数，下面列出我在小地图插件使用的例子
function search (x) { /* do something */ } 
var arr2 = ['1', '2', '3', '4']; // 这个存储的是路径，1 2 3 4表示的是不同的行进方向
arr2.reduce(function (acc, curr) {
    search(acc); // 将行进方向依次加起来并执行这个函数，实现搜索目标地图
    return acc + '-' + curr;
});
```

### reduceRight

又见到`reduce`了...

这个和reduce相同，只不过遍历顺序变成了从右向左，其他的完全相同

### flat

这个听不懂就算了...（开摆）

按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回，用于减少数组嵌套层数，用法：`Array.flat(depth?)`

只有唯一一个参数，但是比之前的几乎所有参数都难...

这个参数规定了返回值的数组减少嵌套层数，不填视为1，相当于减少一层嵌套

```js
var arr = [1, [2, [3, [4, [5]]]], [2, 3, [4]]];
var res1 = arr.flat(); // [1, 2, [3, [4, [5]]], 2, 3, [4]] 减少一层嵌套
var res2 = arr.flat(Infinity); // [1, 2, 3, 4, 5, 2, 3, 4] 去除所有嵌套
var res3 = arr.flat(2); // [1, 2, 3, [4, [5]], 2, 3, 4] // 去除两层嵌套
```

### flatMap

这个还好吧，应该能懂

会对所有项进行`map`操作，然后减少一层嵌套层数

不举例子了...