# 第二章 第七节 对象进阶

在本节中，我们会接触一种新的对象概念

## 导入: new 操作符

如果你曾经看过样板代码，那可能看到过如下语句。

```js
var main = new main();
```

这个语句看起来很像执行函数，但是它在前方加了一个特殊的关键字`new`，这带来了完全不同的意义，我们接下来会讲解这种语法

## 构造函数

首先看一下这段代码

```js
function Obj() {
    this.a = 1;
}
var obj = new Obj();
obj.a // 1
```

注意到，`Obj`函数并没有返回值，但是却返回了一个对象，这个函数被称为构造函数，它与普通的函数使用同样的方法声明，只是在调用的时候需要加上`new`

观察一下第二行和第五行，可以发现函数执行了一个`this.a = 1`的语句，使得obj上拥有了一个属性`a`，这是就是构造函数定义成员的方法。

构造函数也可以接受参数，可以使用参数来设定初始化值

```js
function Obj(_a) {
    this.a = _a;
}
var obj = new Obj(1);
obj.a // 1
```

当你多次调用构造函数时，会生成多个独立的对象

```js
function Obj(_a) {
    this.a = _a;
}
var obj1 = new Obj(1);
obj1.a // 1
var obj2 = new Obj(2);
obj2.a // 2
```

## 方法

你可能已经注意到了，在之前的教程中，我们将成员函数称为`方法`，显然，这是因为成员函数拥有某种特殊的性质，接下来我们会讲解如何声明方法，以及它的特殊能力。

我们使用`构造函数.prototype.方法名 = function`的形式来声明方法（样板中几乎所有的函数都是以这种形式声明的）例如说：

```js
function Counter() {
    this.value = 0;
}
Counter.prototype.count = function() {
    this.value++;
}
```

在声明之后，就可以用成员运算符调用这个函数。

```js
var counter = new Counter();
counter.value // 0
counter.count();
counter.value // 1
```

可以看到，我们在方法中执行了`this.value++`，随后`counter.value`就增加了1，这涉及到一个复杂的概念`this`

### 神秘的this

`this`这个关键字可以被认为是调用对象的引用，类似于上一节中分析引用类型的方法，我们来分析一下刚刚的语句中`this`的情形


```js
var counter = new Counter();
// 内部的情况: this = ref(counter) 因此就是 counter.value = 0
    function Counter() {
        this.value = 0;
    }
counter.value // 0
counter.count();
// 内部的情况: this = ref(counter) 因此就是 counter.value++
    Counter.prototype.count = function() {
        this.value++;
    }
counter.value // 1
```

## 原型链

`prototype`究竟是啥呢，实际上它是一种被称为原型链的机制，当我们在一个由构造函数生成的对象上调用方法时，引擎首先会查找该对象上是否有需要的方法和属性，如果没有找到，会尝试去构造函数的原型对象上寻找，这一过程会递归的进行，例如说：

```js
function Brray() {

}
Brray.prototype = [];

var b = new Brray();
b.length // 0
```

设置函数的原型被称为继承，继承可以复用之前的构造函数所声明的各种方法和对象。

### instanceof

`instanceof`运算符用于判断某个对象是否是是由某个函数构造的，例如说

```js
function A() {

}
var a = new A();
a instanceof A // true
```

更进一步的，`instanceof`可以沿着原型链进行检查

```js
function A() {

}
A.prototype = [];
var a = new A();
a instanceof Array // true
```

## this的指向

在函数中，this总是会指向它所在的函数，因此使用函数式api时会发生不必要的问题，例如说：

```js
A.protoype.rmap = function() {
    [].map(function() {
        console.log(this.length);
    });
}
```

此时，在内部函数中的this并不会指向`A`的实例，而是指向它所在的回调函数，在`ES6`之前这产生了很痛苦的问题，人们往往需要声明`that`或者`self`之类的变量在外部暂存`this`，不过`ES6`引入的箭头函数不存在这个问题，你可以直接这么使用

```js
A.protoype.rmap = function() {
    [].map(() => {
        console.log(this.length);
    });
}
```

更痛苦的事情将在把方法储存到变量时产生，如果你像下面这么做，会发生什么呢？

```js
var fmap = [1].map;
fmap((e) => e * 2);
```

如果你自己尝试运行过，会发现这将报错，实际上，对象的`this`指向还遵守另外一个规则：它的`this`将指向它所属的对象，如果你在全局作用域中调用它，它将指向`undefined`，因此任何从`this`上取属性的操作都会报错

### bind call apply

js提供了`bind`, `call`, `apply`三个函数用于解决指向问题，这三个函数的用法比较奇怪，它们是函数的方法，因此是这么调用的。

```js
var a = [1].map.bind([2]);
```

`bind` 方法会返回一个将this指向第一个传入参数的函数，也就是说，上面这个函数的运行结果会是这样

```js
a((e) => e) // [2] 因为this指向的是[2]
```

而`call`和`apply`则是一次性的调用，`call`的第一个参数将作为this的指向，而后面的参数则作为函数参数

```js
var a = [1].map;
a.call([2], (e) => e); // [2]
```

`apply`和`call`类似，但是它的第二个参数是一个数组，所有要传递给函数的参数以数组形式传入

```js
var a = [1].map;
a.apply([2], [(e) => e]); // [2]
```

这个方法的另外一个用途就是直接的以数组形式传参

```js
var a = [ 1, 2, 3 ];
var b = [ 4, 5, 6 ];
a.push.apply(a, b);

a // [ 1, 2, 3, 4, 5, 6 ] 没有concat的时代，人们就是这么干的
```

### 简单的解决方法

如果你对此感到恐惧，你可以拒绝把方法赋值到别的地方，作为代替，你可以声明一个包含方法调用的函数

```js
() => a.xx();
```

## 面向对象编程

到目前为止应该不难理解，但是也许你会有这样的疑问：为什么要这么做，搞这么麻烦有什么用吗。

实际上，这是一种编程的范式，被称为面向对象编程（你有女朋友吗x）。面向对象编程的要旨是封装，继承和多态，不过这太复杂了，在本节中我们只会简单解释前两个词，在第二部分我们会讨论更多内容。

### 什么是封装

首先我们可以考虑一下，如果不使用对象，我们要如何调用`Array.map`？也许我们会这么做（实际上有一门叫`php`的语言就是这么干的）

```js
array_map(arr, (e) => e);
```

这看起来有一点蠢，首先，多写了`array`这个词用于给函数起名，而从语义的角度上来说，主语 - 谓语 - (宾语) 的结构对于人类更友好。

最重要的一点：这是一个必须传入一个数组的函数，但是当你试图调用这个代码的时候，命名空间里可能充斥着一堆`abort`, `access`, `abandon`，之类完全不相干的函数，于是你很难使用代码联想来找到这个函数。这是封装的一个重要作用：将一组相关的变量和方法放到一个对象中，使得你可以方便的获得它们，并且进行修改

### 继承有啥用

我们在原型链部分已经讲了继承的操作方法，其用途是进行代码的复用，如果你需要大量相似的对象，可以将一个公共的对象作为原型。

不过，继承一个不是为被继承而设计的对象是危险的。

### 你可能不需要构造函数

如果你到现在还是不理解构造函数有啥用的话，那就不用吧，js是一个多范式编程语言，面向对象编程的支持并不太好（所以确实是没啥用）。

实际上，安排本节课的主要原因是，JS有很多内置的构造函数，因此你需要会调用它们。所以，如果你完全没理解的话，记住以下内容就行。

## 太长不看版

你可以用 `new` 关键字从函数中生成一个对象。

你可以用 `函数.prototype.xxx` 修改所有这么生成的对象所具有的方法。

你可以用 `instanceof` 判断对象是不是由某个函数生成的。
