# 第四章 第六节 触发
## 「触发系统事件」指令
造了这么久塔，作者们应该无人不知这个大杀器一般的指令了。它的JSON代码写作`{"type": "trigger", "loc": [x,y]}`，那么它到底执行的是一个什么样的流程呢？
``` js
events.prototype._trigger_inAction = function (x, y) {
    if (core.status.gameOver || core.status.event.id != 'action') return;
    var block = core.getBlock(x, y);
    if (block == null) return core.doAction();
    // 执行该点的脚本
    try {
        eval(block.event.script);
    } catch (ee) { console.error(ee) }
    // 碰触事件
    if (block.event.event) {
        core.clearRouteFolding();
        core.insertAction(block.event.event, block.x, block.y);
        // 不再执行该点的系统事件
        return core.doAction();
    }
    if (block.event.trigger && block.event.trigger != 'null') {
        this.setEvents(null, x, y);
        if (block.event.trigger == 'action') {
            this.insertAction(block.event.data);
        }
        else {
            this.doSystemEvent(block.event.trigger, block, core.doAction);
            return;
        }
    }
    return core.doAction();
}
```
用人话来说就是：
1. 获取该点的图块信息，如果是空地则跳过以下所有步骤。
2. （怪物和道具除外）检查图块属性的「碰触脚本」并执行。
3. （怪物和道具除外）检查图块属性的「碰触事件」，如果有，则中止寻路、插入执行该事件，并跳过以下所有步骤。
4. 检查图块属性的「触发器」，如openDoor、changeFloor、pushBox等，怪物和道具的触发器分别是battle和getItem但这两个不可见，红点（普通事件）的触发器是action。如果该图块没有触发器则跳过以下所有步骤。
5. 根据触发器的类型执行不同行为，红点是直接插入执行事件内容，其他的则在下一段详述。

「碰触脚本」和「碰触事件」的主要区别是前者没法直接获得该图块的坐标，比如changeLight（踩灯）图块就不得不使用勇士坐标，因此异地触发就会出现「亮着的灯无动于衷，勇士脚下却变成踩过的灯」这种离谱效果。
## action（普通事件，红点）
``` js
events.prototype._sys_action = function (data, callback) {
    var ev = core.clone(data.event.data), ex = data.x, ey = data.y;
    // 检查是否需要改变朝向
    if (ex == core.nextX() && ey == core.nextY()) {
        var dir = core.turnDirection(":back");
        var id = data.event.id, toId = (data.event.faceIds || {})[dir];
        if (toId && id != toId) {
            var number = core.getNumberById(toId);
            if (number > 0)
                core.setBlock(number, ex, ey);
        }
    }
    this.insertAction(ev, ex, ey, callback);
}
```
这个函数只有在勇士「自由行动」时撞击NPC才会触发，跟上一段的「触发系统事件」指令无关。两者的区别也仅仅是该NPC会转身面向勇士而已（这个逻辑自己写也不难），而且事件结束以后还不会自动转回原朝向，就离谱。
## battle（战斗）
``` js
events.prototype._sys_battle = function (data, callback) {
    // 检查是否需要改变朝向（略，已被小艾注释掉）
    // 检查战前事件，可以交换两个push的顺序来确定先执行批量还是先执行单点
    var beforeBattle = [];
    core.push(beforeBattle, core.floors[core.status.floorId].beforeBattle[data.x + "," + data.y]);
    core.push(beforeBattle, (core.material.enemys[data.event.id] || {}).beforeBattle);
    if (beforeBattle.length > 0) {
        core.push(beforeBattle, [{ "type": "battle", "x": data.x, "y": data.y }]);
        core.clearContinueAutomaticRoute();
        // 自动存档
        var inAction = core.status.event.id == 'action';
        if (inAction) {
            core.insertAction(beforeBattle, data.x, data.y);
            core.doAction();
        } else {
            core.autosave(true);
            core.insertAction(beforeBattle, data.x, data.y, callback);
        }
    } else {
        this.battle(data.event.id, data.x, data.y, false, callback);
    }
}
```
由于小艾的疏忽，起初他将「撞击怪物时怪物转向」写在了自动存档前，导致读取该存档后怪物已经转向了，因此他后来不得不将转向的逻辑注释掉。
>思考题：尝试修复这一特性实现正确的效果。

使用「触发系统事件」指令或直接撞击怪物，与使用「强制战斗」指令最大的区别是，前者会触发该怪物属性中的「（批量）战前事件」和该点的「战前事件」，以后想给boss制作战前剧情或给某个ID的怪物批量制作战前特效就很方便了。

因此，_sys_battle的执行流程是：
1. 检查两种战前事件并确定执行顺序，如果两者都不存在则跳过以下步骤直接开打（battle函数）。<br>注意尽管这里的自变量force传入了false，但该false只在自由行动时生效，换句话说用「触发系统事件」指令去触发怪物是没有仁慈判定的，打不过直接死亡。
2. 如果至少存在一种战前事件，则将「强制战斗」指令追加到这组事件的末尾，然后中止寻路。
3. 中止寻路后，检查本次战斗是事件中的还是自由行动时撞击导致的，如果是后者则要先自动存档。
4. 将以「强制战斗」指令结尾的战前事件列表插入执行。
``` js
////// 战斗 //////
events.prototype.battle = function (id, x, y, force, callback) {
    core.saveAndStopAutomaticRoute();
    id = id || core.getBlockId(x, y);
    if (!id) return core.clearContinueAutomaticRoute(callback);
    // 非强制战斗
    if (!core.enemys.canBattle(id, x, y) && !force && !core.status.event.id) {
        core.stopSound();
        core.playSound('操作失败');
        core.drawTip("你打不过此怪物！", id);
        return core.clearContinueAutomaticRoute(callback);
    }
    // 自动存档
    if (!core.status.event.id) core.autosave(true);
    // 战前脚本
    if (!this.beforeBattle(id, x, y))
        return core.clearContinueAutomaticRoute(callback);
    // 战后脚本
    this.afterBattle(id, x, y);
    if (callback) callback();
}
```
battle函数就更简单了：
1. 暂停寻路并保存剩余步伐（适用于自由行动时拖动穿过几个怪物连续战斗）。
2. 检查怪物ID是否存在，如果不存在则尝试从坐标获取（因为「强制战斗」指令有一种就是只指定坐标的），如果还获取不到，那就放弃下列所有步骤。
3. 执行仁慈判定：当自变量force为false且不是事件中战斗时，调用canBattle函数判断能否战胜（其默认逻辑是计算怪物伤害与勇士生命比较，可以修改成自己的逻辑），不能战胜时则放弃下列所有步骤。
4. 如果不是事件中战斗，则自动存档，且显然不会和_sys_battle中的自动存档相冲突。
5. 执行「战前脚本」，处理支援怪的跳跃效果并将它们写入flag确保等一下勇士掉血数值正常。
6. 战前脚本中返回false会放弃战斗（被支援怪的战斗由「强制战斗」指令重新触发），返回true则执行「战后脚本」，那就是作者们熟悉的部分了。
## changeFloor（楼梯，绿点）
绿点楼梯比起直接使用「楼层切换」指令，其多出的功能是可以指定「穿透性」，尽管这个功能对键盘玩家很不友好且会导致一个隐患：
>楼梯旁边没有障碍物时，只有直接编辑录像才能停在楼梯上。

有的作者不知道这一点，试图在楼梯旁边放领域来暗示玩家要「压血停在楼梯上」，但其实不需要，反而是便宜了Dclean和CC等流氓玩家，因此秋橙在此严正指出这一点。

样板这方面的漏洞挺多的，类似的还有「瞬移到勇士相邻的格子」、「向任意角度转身（Z键只能顺时针转90度）」、「读取自动存档后录像最后一项变成转身」等。

楼梯的执行流程如下：
1. （自由行动时走到楼梯上）检查当前寻路是否有剩余步伐（如果是回放录像时则检查即将播放内容toReplay的第一项是否为'no'），如果有剩余步伐（录像项为'no'）则无视本次触发楼梯。
2. 确定本次传送的目标地图、目标点和勇士的新朝向，然后调用changeFloor函数执行传送，传送前要更新黑屏淡出的目标地图title。
3. 目标地图的确定有「直接指定ID」和「`:before :next :now`」相对指定法两种。
4. 目标点的确定同样有「直接指定绝对坐标」和「保持不变或三种对称」相对指定法两种，注意相对指定时用的是「勇士在当前地图」的坐标。<br>这句话有两层意思：一是「不是楼梯的坐标」，换句话说楼梯最好设置成可通行，否则从四个方向撞击会有不同的效果；二是「不是目标地图」，换句话说如果两个楼层的尺寸（在某个方向）不一致时要慎用这个方向的对称指定法。
5. 勇士新朝向的确定有「四种绝对指定（上下左右）」和「四种相对指定（逆时针转0 90 180 270度）」法。
6. 楼层切换的音效会在「屏幕开始变黑淡出」前一瞬间开播，而当屏幕重新变亮淡入后会执行两个arrive事件（如果是读档则会检查是否需要恢复事件现场），firstArrive是否执行取决于flags.__visited__是否已到过该层，楼传可达性同理。

startText（开场剧情）结束时会进入出生楼层，某些使用了「标题界面事件化」的作者也会在标题事件中切换到一个剧情层）。
>思考题：如果觉得这次楼层切换的音效不合气氛想临时取消之，可以怎么做？至少给出两种做法。
## getItem（拾获道具）
``` js
events.prototype._sys_getItem = function (data, callback) {
    this.getItem(data.event.id, 1, data.x, data.y, false, callback);
}
////// 获得某个物品 //////
events.prototype.getItem = function (id, num, x, y, isGentleClick, callback) {
    if (num == null) num = 1;
    var itemCls = core.material.items[id].cls;
    core.removeBlock(x, y);
    core.items.getItemEffect(id, num);
    var text = '获得 ' + core.material.items[id].name;
    if (num > 1) text += "x" + num;
    if (itemCls === 'items' && num == 1) text += core.items.getItemEffectTip(id);
    core.drawTip(text, id);
    // --- 首次获得道具的提示（略）
    this.afterGetItem(id, x, y, isGentleClick);
    if (callback) callback();
}
```
其执行流程为：
1. 确定所拾获道具的ID（和类别）、数量（默认为1）、坐标（如果有则会删除该点图块）、是否是轻按。
2. 判定该道具的类别，如果是items（即捡即用）则先将其itemEffect执行num次（并统计勇士生命变化），然后将其useItemEvent（碰触或使用事件）执行一次且无法统计（很诡异的双标）。如果不是items则直接更改道具数量。
3. 显示提示文字，默认为「获得+空格+道具名称+x+num」，num为1时略去「x+num」并判断是否为items，如果是则追加形如「，攻击+1」这样的效果说明。

getItem是样板几个系统触发器里秋橙认为写得最烂的，没有之一。

首先轻按无法触发_sys_getItem，且轻按的逻辑也写得很糟糕。判定时优先判定面前，其次按上下左右顺序，但录像中又不记录具体的方向。

然后说说这个getItem函数，首先num和坐标同时给出就是一个非常奇怪的设定，难道地上的一个点会有多个同一道具么？其次，道具的cls字段也是一个很诡异的设定。

constants（永久道具）、tools（消耗道具）、equips（装备）是不需要「图块」的，因为它们可能压根就不出现在地图上（永久道具和装备往往是唯一的，要么从商店购入要么由NPC随着剧情给予），就算需要出现在地图上（如钥匙、红海的破炸飞）也不应该是静态的（来点闪烁效果不好么？），样板之所以把道具全做成静态的只是因为背包里没法播放踏步动画而已。

constants的本质是「一个true或false的开关决定玩家是否有权使用某功能」，比如手册和楼传完全可以是两个取值为true或false的flag，反正玩家都是按快捷键或按钮使用它们对不对？

tools则稍微复杂一点，本质是一个「取值为0,1,2,...的变量」，变量大于0时玩家有权使用某功能，使用成功时该变量-1，样板不是也提供了破炸飞的123快捷键么？完全可以将对应的道具数量用flag记录。

equips更为复杂，作者们可以自己思考一下，constants和tools的「某功能」列表可以以全局商店的形式提供。

items（即捡即用，如血瓶和宝石）是最诡异的，首先我们已经看到有「钥匙盒」和「同色钥匙串」这样的存在了，前者是样板自带的，后者在很多塔里有。那么为什么单独一把钥匙或者别的什么tools就要直接放在地图上呢？难道不应该把所有的道具都做成普通的可通行图块（这样还可以两到四帧或者用大型行走图）然后在勇士踩踏它时执行对应的效果么？加血、加能力、改变某某flag（对应constants和tools）等。

这样重构以后好处很明显，而且通过简单的适配就能继续使用目前的afterGetItem脚本和事件。

劣势也有：首先轻按的逻辑要自己重新写（完整学完本节以后你们都能做到），其次和现有的「数据统计」功能不兼容，可以尝试重新适配，不过数据统计本身就是漏洞百出的天坑。

怪物也有类似的问题，比如「四个朝向的怪物要写四份一样的数据」，如果把怪物抽象成没有图块的对象，再用其他普通图块的「碰触脚本」去触发战斗就会合理许多。当然，要重新适配的部分（如阻激夹域）就更多了……
>思考题：rm有「敌群」这一概念，而h5的「小队战斗」则默认只能通过支援触发。如果将某个ID的普通图块设为不可通行，并将其「碰触脚本」的内容写为「与一只被两名初级卫兵支援的小蝙蝠战斗（都是天降），战后该图块消失」，是不是很方便呢？尝试实现一下吧！
## openDoor（开门）
``` js
events.prototype._sys_openDoor = function (data, callback) {
    this.openDoor(data.x, data.y, true, function () {
        core.replay();
        if (callback) callback();
    });
}
```
如果不考虑开门动画，开门本身其实是一个非常平凡的逻辑：撞击某某图块，判定某某条件，条件满足时图块消失并执行某某效果。破冰镐和单方向的破墙镐就是最简陋的钥匙，冰冻徽章则是一种万能铁门钥匙。

思考题：请使用「碰触事件」实现一种门，要求该门在开启前是4帧踏步动画，开启条件不局限于「持有至少指定数量的某些道具」（甚至可以是非自动的开启，比如要求玩家在多种代价中选一种），开启成功和失败有不同的特效，开启成功时的代价不局限于「消耗指定数量的某些道具」，开启过程中帧数「不限」。
>提示：rm的门是用同一个行走图转身三次来开的。<br>进阶：如何让该门适配现有的「开门」和「关门」事件指令以及afterOpenDoor脚本和事件？
## pushBox（推箱子）
``` js
events.prototype.pushBox = function (data) {
    if (data.event.id != 'box' && data.event.id != 'boxed') return;
    // 判断还能否前进，看看是否存在事件
    var direction = core.getHeroLoc('direction'),
        nx = data.x + core.utils.scan[direction].x, ny = data.y + core.utils.scan[direction].y;
    // 检测能否推上去
    if (!core.canMoveHero()) return;
    var canGoDeadZone = core.flags.canGoDeadZone;
    core.flags.canGoDeadZone = true;
    if (!core.canMoveHero(data.x, data.y, direction)) {
        core.flags.canGoDeadZone = canGoDeadZone;
        return;
    }
    core.flags.canGoDeadZone = canGoDeadZone;
    var nextId = core.getBlockId(nx, ny);
    if (nextId != null && nextId != 'flower') return;
    core.setBlock(nextId == null ? 'box' : 'boxed', nx, ny);
    if (data.event.id == 'box')
        core.removeBlock(data.x, data.y);
    else
        core.setBlock('flower', data.x, data.y);
    // 勇士前进一格，然后触发推箱子后事件
    core.insertAction([
        {"type": "moveAction"},
        {"type": "function", "function": "function() { core.afterPushBox(); }"}
    ]);
}
```
推箱子只对黄箱子（box）和绿箱子（boxed）有效，推动时要求「勇士（在当前位置）可以前进一格」且「假设勇士站在箱子上，（在该位置）也可以前进一格」且「推到的目标点是空地或绿花（flower）」。

将箱子推到绿花上会使其变成绿箱子，将绿箱子推走则绿箱子原来的位置变成绿花，将黄箱子推走则黄箱子原来的位置变为空地。
>思考题：var canGoDeadZone的作用是什么？如果使用「触发系统事件」远程推箱子会发生什么？
## ski（滑冰）、custom（自定义）
滑冰其实不应该是一个「触发器」了，因为它是画在背景层的，且执行原理也很简单：

每走一步后（结尾）判断背景层是不是冰，如果是则将「勇士前进一格或撞击」指令插入到当前事件流的末尾（也就是在阻激夹域动画结束后执行）。

自定义触发器也基本没用了，碰触脚本和碰触事件不香么。
>思考题：[《绝不回头》](https://h5mota.com/games/sana2/)中的图块都是怎样触发的？数字1~8和其他图块的触发方式有何异同？选取复活点是如何做到动态生成选择项列表的？