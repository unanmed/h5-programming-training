# 第二章 第二节 函数进阶

## 一 递归

在函数内部调用自身被称为递归

```js
function func () {
    console.log(1);
    func();
}
func();
```

这就是一个典型的递归的例子。不过如果这样执行，它会死循环吗？不，下面我们就来看一下会发生什么

### 递归过多——爆栈

如果你执行上述代码的话，最后会得到一个报错`Uncaught RangeError: Maximum call stack size exceeded`，这里我们不必深究其原因，只要知道它代表递归次数过多，出现的报错即可。不同设备的可递归次数不一定相同，所以在程序中尽量不要有大剂量的递归 :)

### 正常递归的例子——斐波那契数列

斐波那契数列是指 1 1 2 3 5 8 13 21 ... 即第`n`项是第`n-1`和`n-2`项的和，下面我们就用递归来实现计算第n项

```js
function cal (n) {
    if (n - 3 < 0) return 1; // n为 1 或 2 时输出1
    return cal(n - 1) + cal(n - 2); // 否则输出前两项的和
}
// 这时我们可以调用cal(n)来计算出第n项的结果
cal(3); // 2
cal(5); // 5
cal(7); // 13
```

这就是递归的正确用法，必须要有条件来终止函数继续递归，否则会爆栈。如果看不懂上面那个例子，可以仔细想一想

## 二 回调函数

在js中，可以在调用函数时传入一个函数作为实参，这个函数就称为回调函数。

```js
setTimeout(function () { console.log(111); }, 1000);
```

上面这个例子中，`function () { console.log(111);`就称为回调函数。（上面这个例子是延迟1000ms执行输出111）

### 回调函数的参数

回调函数也可以有形参，实参由被调用的函数本身提供，例如

```js
function myFunc (callback) {
    var x = 10;
    callback(x); // 这里的x是回调函数的实参
}

myFunc(function (x) { console.log(x * 10); }); // 这里的x是回调函数的形参
```

在上面这个例子中，我们在调用函数`myFunc`时，传入了一个回调参数，拥有一个形参x，然后程序会执行函数`myFunc`的内容，声明变量`x`为`10`，然后将`x`作为实参传入回调函数中，回调函数的形参`x`接受传入的实参`x`，输出`x * 10`

## 三 高阶函数

高阶函数指返回函数的函数

```js
function myFunc(x) {
    return function (y) {
        return x + y;
    }
}
myFunc(1)(2); // 因为myFunc的返回值为一个函数，所以我们在调用过一次以后可以立即再次调用，便出现了两个()
```

我们来解析一下上面的内容

首先，程序执行时，首先执行`myFunc(1)`，这样将会得到一个返回值，返回值为另一个函数，这时候相当于`myFunc(1)`变成了一个函数，又可以通过`(2)`来调用，就出现了两个`()`，于是在执行之后便会返回`1+2`，结果为3


### 四 立即执行函数 IIFE

在某些特殊情况下，我们会希望立即执行一个临时的函数，例如说，跳出多层循环：

```js
for (var i = 0; i < x; i++) {
    for (var j = 0; j < x; j++) {
        if (i + j === 10) {
            // 想在这里跳出，但是break只能跳出一层，很尴尬
        }
    }   
}
```

在这种时候，我们可以借助临时函数的`return`语句来解决问题

```js
(function() {
    for (var i = 0; i < x; i++) {
        for (var j = 0; j < x; j++) {
            if (i + j === 10) {
                return i*j; // 直接跳出两层
            }
        }   
    }
})();
```

这种形式被称为立即执行函数，简称`IIFE`，在编写`IIFE`时，声明的函数要用小括号包裹才能执行调用


### 五 箭头函数

> 截止目前，请不要在样板中使用这一语法，这个语法无法通过压缩

在2015年，js引入了一种新的声明函数的方法`箭头函数`，用于声明临时的，没有名字的函数

箭头函数的语法非常简单: `(参数) => { 函数体 }`，相当于`function (参数) { 函数体 }`

举例子：

```js
var myFunc = (x) => {
    return (y) => {
        return x + y;
    }
}
```

特别的，如果函数体只有一条语句，可以省略大括号，这条语句的值会做为整个函数的返回值

```js
// 改写上面的函数
var myFunc = (x) => {
    return (y) =>  x + y;
}
// 还可以这样！
var myFunc = (x) => ((y) => x + y);
```

如果函数只有一个参数，甚至可以省掉形参的括号（不推荐

```js
// 甚至可以这样！如果你还看得懂的话
var myFunc = x => y => x + y;
```

箭头函数也可以作为`IIFE`，语法如下

```js
(() => {
    console.log("a");
})();
```

特别的，箭头函数中无法使用`arguments`来获取传入参数，从编程风格来说，推荐将所有具名的函数写成`function`形式，而作为参数或者返回值的函数则写成箭头函数形式
