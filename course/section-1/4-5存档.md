# 第四章 第五节 存档
本节将讲述样板存读档系统所有不涉及网络或文件系统的部分，换言之不包括「云同步」和「h5save文件读写」。
``` js
events.prototype._action_callSave = function (data, x, y, prefix) { // 「呼出存档页面」指令
    if (core.isReplaying() || core.hasFlag("__events__")) { // 录像回放中，跳过
        core.removeFlag("__events__"); core.doAction();
    } else {
        var e = core.clone(core.status.event.data); // 备份当前事件现场，存档或取消后恢复
        core.ui.closePanel(); var forbidSave = core.hasFlag('__forbidSave__');
        core.removeFlag('__forbidSave__'); // 临时解禁存档，适用于RPG迷宫中的固定存档点
        core.save(); // 正式呼出存档页面
        if (forbidSave) core.setFlag('__forbidSave__', true);
        core.status.event.interval = e;
    }
} // 思考题：如果要允许玩家存多个档，直到手动关闭存档页面才继续事件，该怎么做。

events.prototype._action_autoSave = function (data, x, y, prefix) { // 「自动存档」指令
    var forbidSave = core.hasFlag('__forbidSave__');
    core.removeFlag('__forbidSave__'); // 临时解禁存档
    core.autosave(); // 可写成 core.autosave(data.nohint); 并配合下面另一处修改来达到「读档后回到事件触发前」的效果。
    if (forbidSave) core.setFlag('__forbidSave__', true);
    // if (!data.nohint) core.drawTip("已自动存档");
    core.doAction();
} // 思考题：这两处修改配合起来以后，有什么注意事项。

events.prototype._action_forbidSave = function (data, x, y, prefix) { // 「是否禁止存档」指令
    core.setFlag('__forbidSave__', data.forbid || null); core.doAction();
} // 思考题：如果要让「禁止存档」对事件中的自动存档指令也生效，该怎么改。

////// 自动存档 //////
control.prototype.autosave = function (removeLast) {
    if (core.hasFlag('__forbidSave__')) return; // 当前是否禁止存档，默认不禁止「自动存档」事件指令
    var x = null;
    if (removeLast) { // 如果是主动撞门/撞怪前的自动存档，要将录像的最后一项由行走改为转身。读档后生效，会导致录像长度+1
        x = core.status.route.pop(); core.status.route.push("turn:" + core.getHeroLoc('direction'));
    }
    if (core.status.event.id == 'action') // 事件中的自动存档要备份事件现场，可在此加上 && !removeLast 并配合上面另一处修改来取消备份从而达到「读档后回到事件触发前」的效果。
        core.setFlag("__events__", core.clone(core.status.event.data));
    if (core.saves.autosave.data == null) { core.saves.autosave.data = []; } // 下面是CC编写的多步撤销/重做逻辑
    core.saves.autosave.data.splice(core.saves.autosave.now, 0, core.saveData());
    core.saves.autosave.now += 1;
    if (core.saves.autosave.data.length > core.saves.autosave.max) {
        if (core.saves.autosave.now < core.saves.autosave.max / 2) core.saves.autosave.data.pop();
        else { core.saves.autosave.data.shift(); core.saves.autosave.now = core.saves.autosave.now - 1; }
    }
    core.saves.autosave.updated = core.saves.ids[0] = true; // 点亮SL界面左上角的自动存档位，并标记下次checkAutosave需要setLocalForage
    core.removeFlag("__events__"); // 删除事件现场的备份，还原原本的录像，然后继续游戏
    if (removeLast) { core.status.route.pop(); if (x) core.status.route.push(x); }
} // 思考题：如何解决「读取自动存档后录像长度+1」的问题？这个问题对Terra等创新塔很致命。假设要对道具或者可通行的怪物/门适配自动存档，那么回退和重做又要注意什么？

/////// 实际进行自动存档 //////
control.prototype.checkAutosave = function () { // 每5秒执行一次，或在标签页/窗口失去焦点时执行
    if (!core.animateFrame || !core.saves || !core.saves.autosave) return; // 游戏还没开始，则不执行
    core.setLocalStorage('totalTime', core.animateFrame.totalTime); // 记录累计游戏时长
    var autosave = core.saves.autosave;
    if (autosave.data == null || !autosave.updated || !autosave.storage) return; // 检查是否需要setLocalForage
    autosave.updated = false;
    if (autosave.data.length >= 1) { core.setLocalForage("autoSave", autosave.data[autosave.now - 1]); }
} // 思考题：累计游戏时长为什么是只增不减的，其记录方法有何不合理之处？

////// 实际进行存读档事件 //////
control.prototype.doSL = function (id, type) { // 会在SL界面点击6个存档位时执行，id为存档编号，本节我们暂且不谈讨core.ui._drawSLPanel以及actions.js对应的交互。
    switch (type) {
        case 'save': this._doSL_save(id); break; // 手动存档
        case 'load': this._doSL_load(id, this._doSL_load_afterGet); break; // 手动读档
        case 'reload': this._doSL_reload(id, this._doSL_load_afterGet); break; // 按下W或6，多步回退后的重做操作
        // 从存档开始回放，要求该存档的录像是当前录像的非空真前缀，会读取该存档并播放去掉前缀的剩余内容
        case 'replayLoad': this._doSL_load(id, this._doSL_replayLoad_afterGet); break;
        // 接续播放剩余录像，要求依次选择两个存档，前者的楼层和坐标与勇士当前相同，且前者的录像是后者的录像的非空真前缀，会以当前游戏状态为基础播放去掉前缀的剩余内容
        case 'replayRemain': this._doSL_load(id, this._doSL_replayRemain_afterGet); break;
        // 播放存档剩余录像，要求该存档的楼层和坐标与勇士当前相同，且该存档是在某个录像播了一半时存的（带有[R]标记），会以当前游戏状态为基础播放该存档中存储的未播完部分
        case 'replaySince': this._doSL_load(id, this._doSL_replaySince_afterGet); break;
    }
} // 思考题：请添加自己的一种新case，例如关闭读档界面后不实际读档，而是以多个「显示文章」指令输出该存档的所有flag值，要求自动分页。

control.prototype._doSL_save = function (id) { // 手动存档
    if (id == 'autoSave') { core.playSound('操作失败'); return core.drawTip('不能覆盖自动存档！'); } // 不能手动覆盖自动存档
    if (core.status.event.interval != null) core.setFlag("__events__", core.status.event.interval); // 「呼出存档页面」指令时的存档，要备份事件现场
    var data = core.saveData(); // 脚本编辑的saveData，你可以决定要存哪些内容
    if (core.isReplaying() && core.status.replay.toReplay.length > 0) { // 如果是录像播了一半时存的，那么要存储未播完部分以供「播放存档剩余录像」使用
        data.__toReplay__ = core.encodeRoute(core.status.replay.toReplay);
    }
    core.setLocalForage("save" + id, data, function () {
        core.saves.saveIndex = id; // 记录最近使用的存档编号，下次打开SL界面定位在这一页
        core.setLocalStorage('saveIndex', core.saves.saveIndex);
        if (!core.events.recoverEvents(core.status.event.interval)) core.ui.closePanel(); // 「呼出存档页面」指令后，要恢复事件现场
        core.playSound('存档'); core.drawTip('存档成功！');
    }, function (err) { main.log(err); alert("存档失败，错误信息：\n" + err); });
    core.removeFlag("__events__"); // 删除事件现场的备份
    return;
} // 思考题：如果flags.__potionNoRouting__对游戏数据有影响（比如会使血网伤害加倍）那么会对录像造成什么后果？类似问题该如何解决。

control.prototype._doSL_load = function (id, callback) {} // 手动读档，详见_doSL_load_afterGet等

control.prototype._doSL_reload = function (id, callback) { // 按下W或6，多步回退后的重做操作
    if (core.saves.autosave.data != null && core.saves.autosave.now < core.saves.autosave.data.length) {
        var data = core.saves.autosave.data.splice(core.saves.autosave.now, 1)[0]; core.control.autosave(false); callback(id, data);
    }
} // 思考题：目前的自动存档在打了ABC三个怪物后如果回退两步再去打DE两个怪物，那么C怪物前的自动存档就丢失了。为了解决这个问题，请尝试理解鹿神的树状存档逻辑并在2.9样板中实现。

control.prototype._doSL_load_afterGet = function (id, data) { // 手动读档
    if (!data) return alert("无效的存档"); // 选择了空的存档位
    var _replay = function () { // 版本不匹配或「跨浏览器读取事件中存档」时改为从头播放录像
        core.startGame(data.hard, data.hero.flags.__seed__, core.decodeRoute(data.route));
    };
    if (data.version != core.firstData.version) {
        core.myconfirm("存档版本不匹配！\n你想回放此存档的录像吗？\n可以随时停止录像播放以继续游戏。", _replay); return;
    }
    if (data.hero.flags.__events__ && data.guid != core.getGuid()) {
        core.myconfirm("此存档可能存在风险，你想要播放录像么？", _replay); return;
    }
    core.ui.closePanel(); // 关闭读档界面
    core.loadData(data, function () { // 脚本编辑的loadData，会设置下一行的flag用于楼层切换时做不同的处理
        core.removeFlag('__fromLoad__'); core.drawTip("读档成功");
        if (id != "autoSave") { core.saves.saveIndex = id; core.setLocalStorage('saveIndex', core.saves.saveIndex); }
    });
} // 思考题：《最终幻想XIII-2》里，从标题画面读档会在正式进入地图之前，先根据该存档的所在章节播放一段前情提要CG。请在2.9样板中实现类似的效果，下一届蓝海赛里这么干可能会很出彩哦。

control.prototype._doSL_replayLoad_afterGet = function (id, data) { // 从存档开始回放
    if (!data) { core.playSound('操作失败'); return core.drawTip("无效的存档"); } // 选择了空的存档位
    if (data.version != core.firstData.version) { core.playSound('操作失败'); return core.drawTip("存档版本不匹配"); }
    if (data.hero.flags.__events__ && data.guid != core.getGuid()) { core.playSound('操作失败'); return core.drawTip("此存档可能存在风险，无法读档"); }
    var route = core.subarray(core.status.route, core.decodeRoute(data.route)); // 判定录像前缀关系，并尝试获取去掉前缀后的剩余内容
    if (route == null) { core.playSound('操作失败'); return core.drawTip("无法从此存档回放录像"); } // 不满足前缀关系
    core.loadData(data, function () { core.removeFlag('__fromLoad__'); core.startReplay(route); core.drawTip("回退到存档节点"); }); // startReplay作为回调，因为要先读档
} // 思考题：如果该存档的flags.__seed__值和当前游戏的此值不相等，那么对使用了「随机数」值块或core.rand()的塔可能有什么影响？如何解决。

control.prototype._doSL_replayRemain_afterGet = function (id, data) { // 接续播放剩余录像，分两步
    if (!data) { core.playSound('操作失败'); return core.drawTip("无效的存档"); } // 选择了空的存档位
    var route = core.decodeRoute(data.route); // 获取这个存档的录像
    if (core.status.tempRoute) { // 如果是第二步
        var remainRoute = core.subarray(route, core.status.tempRoute); // 判定两个存档的录像前缀关系，并尝试获取去掉前缀后的剩余内容
        if (remainRoute == null) return alert("无法接续播放录像！\n该存档必须是前一个选择的存档的后续内容。"); // 不满足前缀关系
        delete core.status.tempRoute; // 清除第一步的临时记录
        core.ui.closePanel(); // 关闭读档界面
        core.startReplay(remainRoute); // 可以看到比起_doSL_replayLoad_afterGet，这个startReplay是直接调用而不是作为loadData的回调，因为是以当前游戏状态为基础播的
        core.drawTip("接续播放录像"); return;
    // 以上是第二步，以下是第一步
    } else if (data.floorId != core.status.floorId || data.hero.loc.x != core.getHeroLoc('x') || data.hero.loc.y != core.getHeroLoc('y'))
        return alert("楼层或坐标不一致！"); // 第一步的存档要求楼层和坐标与勇士当前一致
    core.status.tempRoute = route; core.ui.closePanel(); // 临时记录第一步的录像，然后关闭读档页面，以便显示第二步的提示
    core.drawText("\t[步骤2]请选择第二个存档。\n\r[yellow]该存档必须是前一个存档的后续。\r\n将尝试播放到此存档。", function () {
        core.status.event.id = 'replayRemain'; core.lockControl(); var saveIndex = core.saves.saveIndex;
        var page = parseInt((saveIndex - 1) / 5), offset = saveIndex - 5 * page;
        core.ui._drawSLPanel(10 * page + offset);
    });
} // 思考题：第一步的提示（包括露珠对此功能的b站教学视频链接）跑哪去了？为什么会设计成这样？有没有办法优化？

control.prototype._doSL_replaySince_afterGet = function (id, data) { // 播放存档剩余录像，会先检查该存档的楼层和坐标与勇士当前是否一致
    if (data.floorId != core.status.floorId || data.hero.loc.x != core.getHeroLoc('x') || data.hero.loc.y != core.getHeroLoc('y'))
        return alert("楼层或坐标不一致！");
    if (!data.__toReplay__) return alert('该存档没有剩余录像！'); // 检查该存档是否是录像播到一半时存的（是否有[R]标记）
    core.ui.closePanel(); // 关闭读档界面
    core.startReplay(core.decodeRoute(data.__toReplay__)); // 和_doSL_replayRemain_afterGet一样直接调用而不是作为回调，因为是以当前游戏状态为基础播的
    core.drawTip("播放存档剩余录像");
    return;
} // 思考题：本功能对楼层和坐标有要求，如果希望「不满足要求时先读取该存档（可能是事件中存档因此不方便手动读取）再播放剩余录像」那么应该怎么改写_doSL_replayLoad_afterGet？
```