# 第四章 第三节 UI绘制

## canvas画布的创建

众所周知 样板是用canvas绘制各种各样的游戏内容的。
canvas，字面意思就是画布，就像画画要画在画纸上一样，在绘制之前，我们需要先创建一个画布，然后再在画布上绘制各种各样的图形。

canvas也是一种html标签。
为了在自己的塔中创建新的画布，我们可以在index.html中仿照bg等画布自己添加：

```html
    <canvas class='gameCanvas' id='bg'></canvas>
    <!-- 新的画布 -->
    <canvas class='gameCanvas' id='newCanvas'></canvas>
    <canvas class='gameCanvas' id='event'></canvas>
```
在css中加入zIndex或者其他样式：
```css
#newCanvas {
    z-index: 114514;
    /* 其他样式 */
}
```

这种做法的好处是比较省事，能省去一些注册的麻烦，但是别人不好抄（
也可以通过dom的`createElement`方法在想要的时候创建一个画布进行绘制

```js
var canvas = document.createElement('canvas');
canvas.id = "canvas1";
canvas.style.width = "416px";
// ……更多操作
document.body.appendChild(canvas);
```

刚刚由`createElement`创建的画布是张大小，名字等都没有，也不属于任何人的元素，我们需要手动设定它的大小，名字以及其他需要用到的属性，并通过`appendChild`等办法把他加入到页面上显示出来。
一个需要研究的问题是画布的位置应该设置到我们想要的位置，这个问题更接近dom这里也不会讲，因为样板内已经为我们封装好了一个叫做`createCanvas`的api，它几乎设置好了一切，想要学习不依赖样板创建画布的话也可以从模仿样板开始，样板是你最好的入门老师。

```js
ui.prototype.createCanvas = function (name, x, y, width, height, z) {
    // name是画布的名字 也是画布之间做区分的工具
    // x y是坐标 width height是画布的宽和高 z决定遮挡关系
    // 内容较多不放源码了 可以自己去开个样板 libs/ui.js搜一下学习
}

// ……
var ctx = core.createCanvas('c1',0,0,416,416);
```

简单提一下，在样板中我们反复使用了px这个单位，px类似于cm这种长度单位，造塔中我们需要知道样板1格的尺寸是32 px，13 * 13格样板的宽高就是32 * 13，也就是416 * 416,同理15 * 15就是480。
这个api的用法请查阅样板自带文档的api手册，在其中样板设置好了一堆属性。最终，新创建的画布的左上角被定位到了游戏界面的左上角（不包括状态栏在内）也就是位置为(0,0)的点。也就是说，如果这么写`core.createCanvas('c1',0,0,416,416)`就会使新创建的画布与游戏界面(13 * 13)正好重合。
溢出游戏界面的内容不会被显示，如果想要显示在游戏界面之外比如说右边加一栏展示，需要额外设置`overflow`这个css属性，或者通过dom操作或者写html把画布放到游戏界面的右边，有兴趣的人可以作为课外拓展学习。

## 绘制各种各样的图形

#### 现在我们已经有了一张画布，想想我们现在可以立刻开始画画了吗？

结合生活经验，我们还缺少一根画笔，否则只能望着画布干瞪眼。还好，canvas这张画布自带了一个万能的画笔，使用canvas的方法`getContext`可以获取这根画笔。`getContext() `方法可返回一个对象，该对象提供了用于在画布上绘图的方法和属性。请注意区分canvas和`canvas.getContext()`，他们是不同的对象，canvas元素自己只是一张纸，是没有绘制能力的。

```js
var canvas1 = document.createElement('canvas');
// 2.x的样板我们写getContext('2d') 获取'2d'这个名字对应的画笔
// 3.0也许我们会写getContext('webgl')啥的（？
var ctx1 = canvas.getContext('2d');
// 样板的createCanvas这个api返回的是context
var ctx2 = core.createCanvas('c1',0,0,100,100);
// ctx2.style.xxx or ctx2.id = 'abc' 试图用context修改canvas的样式和属性是错误的
var canvas2 = ctx2.canvas; // 可以通过context.canvas回到canvas上再修改
canvas2.style.display = 'none';
```

`getContext("2d")`对象的属性和方法非常多，我们没有足够的篇幅细讲，可以从网络上(比如说:<https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D>)查找他的方法和属性，这里简单举几个常用的例子：

```js
ctx.fillStyle = "red"; // fillStyle属性设置填充的颜色样式
ctx.fillRect(20, 20, 100, 80); // 在(20,20)的位置绘制一个长100px 宽20px的红色矩形

ctx.fillStyle = "#000000";
ctx.font = "16px verdana"; // font属性会设置字体 16px是大小 verdana是字体名
// textAlign属性和绘制的x坐标有关 设置为center简单解释就是[居中对齐]
// 配合下面的fillText来解释就是在画布上绘制出的内容"11A11"的对称轴位于x=114的位置
ctx.textAlign = "center";
ctx.fillText("11A11", 114, 514); // fillText会根据(114, 514)的坐标绘制文字 关于位置的细节与textAlign和textBaseline两个属性有关 这两个属性在网上就能找到许多图解。

ctx.strokeStyle = "rgba(255,0,0,0.7)";// strokeStyle 属性设置或返回用于笔触的颜色、渐变或模式。
ctx.lineWidth =  5;// lineWidth是线宽 数值越大我们就用越粗的笔绘制线段
ctx.strokeRect(20,20,150,100);// strokeRect与fillRect的不同在于strokeRect将会绘制一个空心的矩形，也就是说并没有进行填充 只是拿笔画出了边框

var img = document.createElement("img");
img.src = "project/bg.jpg";
```

***
最后我们介绍一下drawImage这个非常常用而且万能而且用法很多样的方法，drawImage就像字面意思一样是绘制图像的方法。
drawImage有三种写法:
`ctx.drawImage(img,x,y)`
`ctx.drawImage(img,x,y,w,h)`
`ctx.drawImage(img,sx,sy,sw,sh,x,y,w,h)`
img是你要使用的图像、画布甚至是视频。也就是说你不仅可以传入一个`<img>`元素,还可以传入`<canvas>`甚至是`<video>`。
你不仅可以把一个图片(或者图片的一部分)绘制(通过修改w和h可以进行放缩)到你的画布上，也可以把另一个画布的内容或者当前视频的某一帧就像图片一样画到你的画布上，样板的浏览地图`core.maps.drawThumbnail`正是使用了这个办法，把新楼层的各个图层都画到另一个画布上，达成了绘制楼层缩略图的效果。
x y代表绘制的位置，w h代表绘制的宽高，用法与fillRect相同。
sx sy sw sh是从图片上裁剪的部分的坐标和裁剪下来的宽和高。
如果你只需要绘制图片的一部分，比如说绘制样板里enemys.png中无数个怪物中的一个，那么你需要找到这个怪物在enemys.png中的位置，即为sx和sy，我们知道怪物的宽高是32 * 32，那么sw，sh也就确定了,使用`ctx.drawImage(img,sx,sy,sw,sh,x,y,w,h)`这个形式的写法即可。

***
经过样板的一次次更新，大部分绘制方法，甚至圆角矩形这种需要多个方法配合才能绘制的图形也被样板在ui.js中封装成了api，比如说我们可以使用`core.drawImage("bg.jpg", …)`使用一个注册好了的图片名而不用临时创建一个img元素绘制，更加方便且不容易出错。造塔的大部分时候都不用使用原生方法而使用封装好的api即可，在实战开始之前，请在api手册中了解ui.js有关内容。
***

#### 在实战开始之前

虽然我们是技术教程，但是光会写脚本是做不成好塔的，更影响作者水平的往往是方法而非工具。
现在我们了解了各种各样的绘制方法进行ui绘制，但在画一个ui前我们首先要做的并不是写代码，而是先有一个大体的设计图，不妨就画出来（或者抄已有作品），把，既能把握最终成品的样子，在写代码的时候也能让脑子更清醒。

## 来进行真正的实战吧！

现在我们以楼传为例讲解UI绘制，想想楼层传送的UI，最大的区域被要传送的楼层的地图所占据，上方是一个大标题"楼层传送"，下方是"返回地图"，右侧是当前楼层的名称，右下角有一串小字提示。
我们使用上面提过的方法简单自己写一个类似的UI：
```js
// 假设我们有一个空白的画布
// core.clearMap("all")
var ctx = core.createCanvas("fly", 0, 0, 416, 416, 100);
core.setAlpha(ctx, 0.8);
core.fillRect(ctx, 0, 0, 416, 416, "gray"); // 绘制背景
core.setAlpha(ctx, 1);

// 使用textAlign和TextBaseline能轻松地让你把文字画在想要的地方
core.setTextAlign(ctx, "center");
core.fillText(ctx, "楼层传送", 208, 50, "#fff", "bold 20px verdana");

core.setTextBaseline(ctx, "bottom");
var rx = 40 + (200 / 2), ry = 416 - 20;
core.fillText(ctx, "返回游戏", rx, ry, "yellow", "17px verdana");

var tx = 40, ty = 150, size = 200;
core.drawThumbnail("MT0",null,{ctx: ctx, x: tx, y: ty, size: size});

// start和alphabetic是textAlign和textBaseline的默认值
core.setTextAlign(ctx, "start");
core.setTextBaseline(ctx, "alphabetic");
core.fillText(ctx, "主塔0层", tx + size + 20, ty + 50,"white");
```

了解了基本的绘制方法后，像楼传这样非常简单的页面我们在几行中就画完了。（鼓掌
现在看看样板的写法：

```js
ui.prototype.drawFly = function (page) {
    core.status.event.data = page; // core.status.event.data是一个类似flags的东西 这里的意思就是存下来当前在哪一页
    var floorId = core.floorIds[page];
    var title = core.status.maps[floorId].title;
    core.clearMap('ui');
    core.setAlpha('ui', 0.85);
    core.fillRect('ui', 0, 0, this.PIXEL, this.PIXEL, '#000000');
    core.setAlpha('ui', 1);
    core.setTextAlign('ui', 'center'); // 使用居中对齐把楼层跳跃和返回游戏放到了最中间
    core.fillText('ui', '楼层跳跃', this.HPIXEL, 60, '#FFFFFF', this._buildFont(28, true)); // this.HPIXEL是页面大小的一半 13*13就是208
    core.fillText('ui', '返回游戏', this.HPIXEL, this.PIXEL - 13, null, this._buildFont(15, true))
    core.setTextAlign('ui', 'right');
    core.fillText('ui', '浏览地图时也', this.PIXEL - 10, this.PIXEL - 23, '#aaaaaa', this._buildFont(10, false));
    core.fillText('ui', '可楼层跳跃！', this.PIXEL - 10, this.PIXEL - 11, null, this._buildFont(10, false));
    core.setTextAlign('ui', 'center');

    var middle = this.HPIXEL + 39;

    // 换行
    var lines = core.splitLines('ui', title, 120, this._buildFont(19, true)); // splitLines将一段文字按最大宽度切分成n部分
    var start_y = middle - (lines.length - 1) * 11;
    for (var i in lines) { // 这里的意思就是如果楼层名太长就分成多行写 样板还有个api<core.drawTextContent()>可以绘制多行文本
        core.fillText('ui', lines[i], this.PIXEL - 60, start_y, '#FFFFFF');
        start_y += 22;
    }

    if (core.actions._getNextFlyFloor(1) != page) { // 如果有可飞的上一层就画上 下面同理
        core.fillText('ui', '▲', this.PIXEL - 60, middle - 64, null, this._buildFont(17, false));
        core.fillText('ui', '▲', this.PIXEL - 60, middle - 96);
        core.fillText('ui', '▲', this.PIXEL - 60, middle - 96 - 7);
    }
    if (core.actions._getNextFlyFloor(-1) != page) {
        core.fillText('ui', '▼', this.PIXEL - 60, middle + 64, null, this._buildFont(17, false));
        core.fillText('ui', '▼', this.PIXEL - 60, middle + 96);
        core.fillText('ui', '▼', this.PIXEL - 60, middle + 96 + 7);
    }
    var size = this.PIXEL - 143;
    core.strokeRect('ui', 20, 100, size, size, '#FFFFFF', 2);// 缩略图的边框
    core.drawThumbnail(floorId, null, { ctx: 'ui', x: 20, y: 100, size: size, damage: true });
}
```
仍然是绘制方法的堆砌，如果对所有绘制方法都比较熟悉是0难度的。
绘制UI的同时，往往也需要写界面交互，我们在后面的章节学习。

#### 拓展部分：了解UI组件化

在造塔群偶尔能听到UI组件化这个词，那UI组件化到底是什么呢？
我们先回想，如果用HTML的方法做一个按钮：

```html
 <button onclick="alert('确认')">确认</button>
```

感觉似乎很简单，用类似的思路，我们能不能写一个createButton函数一键在某个地方创建一个按钮呢？

```js
function button(data) {
    this.x = data.x || 0;
    this.y = data.y || 0;
    this.w = data.width || 32;
    this.h = data.height || 32;
    this.id =  data.id || "_btn";
    this.disable = false;

    this.context = core.createCanvas(this.id, this.x, this.y, this.w, this.h, 100);
    this.canvas = this.context.canvas;
    this.update = function() {
        this.context.clearRect(0, 0, this.w, this.h);
        if (this.disable) return;
        core.strokeRect(this.context, 0, 0, this.w, this.h, "#fff", 4);
        this.context.textAlign = "center";
        this.context.textBaseline = "middle";
        core.fillText(this.context, "确认", this.w / 2, this.h / 2, '#000', "12px verdana");
    }
    this.update();

    // 实际上因为事件冒泡机制不会alert 造塔中最好使用core.registerAction代替onclick 这里仅作为样例供理解
    this.canvas.onclick = () => if (!this.disable) alert("确认");
}

// 现在我们有了一个组件 把组件放上去：
var btn = new button({
    x:50,
    y:50,
    width:48,
    height:48,
    id:"btn1",
});
```

组件化的思想认为我们绘制的UI可以抽象成n个独立的组件，组件具备完整的局部功能，通过组件的自由组合来构成所需要的UI。组件化的UI可读性强，逻辑清晰，便于修改，简单来说就是会自然好，不会对于造塔而言掌握基础的绘制方法也足够了。

作业：随便画点东西吧。