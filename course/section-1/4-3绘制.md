# 第四章 第三节 UI绘制

## canvas画布的创建

众所周知 样板是用canvas绘制各种各样的游戏内容的。
canvas，字面意思就是画布，就像画画要画在画纸上一样，在绘制之前，我们需要先创建一个画布，然后再在画布上绘制各种各样的图形。

#### 方法一

canvas也是一种html标签。为了在自己的塔中创建新的画布，我们可以在index.html中仿照bg等画布自己添加：

```html
<!-- 新的画布 -->
<canvas class='gameCanvas' id='newCanvas'></canvas>
```

#### 方法二

也可以通过dom的`createElement`方法在想要的时候创建一个画布进行绘制

```js
var canvas = document.createElement('canvas');
canvas.id = "canvas1";
canvas.style.width = "416px";
// ……更多操作
document.body.appendChild(canvas);
```

#### 方法三

但是为什么不使用样板已经封装好了的api呢（）

在h5魔塔样板中，可以使用`core.createCanvas(name, x, y, width, height, z)`创建一个画布

```js
var ctx = core.createCanvas('c1',0,0,416,416, 55);
```

`createCanvas`接收五个参数，分别为画布id，以及画布的坐标，宽高，以及画布互相覆盖的优先级，可以从样板自带的文档中找到**个性化**查看z值的大小，以上面创建的画布为例，z=55的画布上绘制的内容将会*覆盖背景层和事件层，被前景层覆盖*。

同时返回一个`Context2d`对象(经常被赋给一个叫ctx的变量)，这个对象上有非常多的绘制方法，通过这个对象我们能在画布上进行多样的绘制。可以从网络上(如说:<https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D>)查找他的方法和属性，这里只对样板中常用的绘制api做介绍，绝大多数情况下使用样板封装好的api已经足够解决造塔中的问题了。

##常用方法

`core.fillRect(name, x, y， width, height, style, angel)`

在画布的对应位置绘制一个实心矩形，style是矩形的颜色，如果angel不为空，将会将矩形旋转对应的弧度(一般是Math.PI*某个值)

绘制圆角矩形可以使用`core.fillRoundRect`


`core.fillCircle(name, x, y, r, style)`

在画布的对应位置绘制一个实心圆，x y为圆心坐标 r为半径


`core.strokeRect(name, x, y， width, height, style, lineWidth, angel)`

在画布的对应位置绘制一个空心矩形，也就是说这个api绘制的是一个矩形边框。

style为边框的颜色，lineWidth为边框线宽，angel同`fillRect`


`core.setAlpha(name, alpha)`

设置接下来要绘制的内容的不透明度 默认为1 如果alpha=0 那么画出的内容将会是透明的


`core.clearMap(name, x, y, width, height)`

clearMap相当于canvas的ctx.clearRect(x, y, w, h) 将会擦除画布上的一个矩形区域

name可以写"all" 代表清空core.canvas上的所有画布(不清空自定义画布)


`core.drawIcon(name, id, x, y, w, h, frame)`

在画布上绘制一个注册好的地图图块，id就是图块的id frame为图块的第n帧 默认绘制第一帧


`core.drawWindowSkin(windowSkin, ctx, x, y, w, h)`

drawWindow是一种特殊的绘制图片方法 根据给好的winskin素材处理后绘制素材图片对应的窗口皮肤

windowSkin为图片名 比如winskin.png啥的


`core.fillText(name, text, x, y, style, font, maxWidth)`

在id为name的画布的对应位置上绘制一段文字(name也可为context2d对象) style为文字的样式 font是文字字体

maxWidth可选，设置后，当文字长度超过maxWidth，将会自动缩小字体以使文字长度小于maxWidth


`core.setTextAlign(name, textAlign)`

设置某段文字的对齐 常用align="left" "right" "center"等 代表接下来绘制的文字左右或居中对齐

效果直接进去看图吧（）<https://www.runoob.com/jsref/prop-canvas-textalign.html>


`core.setTextBaseline(name, baseline)`

设置某段文字的基准线 常用baseline="top" "bottom" "middle"等

效果直接进去看图吧（）<https://www.runoob.com/jsref/prop-canvas-textBaseline.html>


`core.drawTextContent(ctx, text, options)`

fillText有个缺陷是只能画一行文字 不能换行 需要绘制多行文本时可以使用`drawTextContent`

options参数是一个对象 `{ left: ?, top: ?, align: ?, maxWidth: ?, fontSize: ?, lineHeight: ?, time: ?, font: ?}`

有多个属性 left top决定文字的文字 align决定对齐方式 

超过maxWidth属性值的宽度的文字将会自动换行 fontSize有关字体大小 需要写数字

lineHeight是一行的高度 默认为fontsize*1.3 如果time不为空 则将会设置打字机效果 font为字体名




`core.drawImage(name, sx, sy, sw, sh, x, y, w, h, angel, reserve)`

sx sy sw sh x y w h的写法可变 与ctx.drawImage相同 详见下面介绍

angel为旋转弧度 reserve可选的值为"x" "y" "o", 分别将会把要绘制的图片进行左右/上下/中心翻转。




***

详细介绍一下drawImage这个非常常用而且万能而且用法很多样的方法，drawImage就像字面意思一样是绘制图像的方法。
drawImage有三种写法:
`ctx.drawImage(img,x,y)`
`ctx.drawImage(img,x,y,w,h)`
`ctx.drawImage(img,sx,sy,sw,sh,x,y,w,h)`
img是你要使用的图像、画布甚至是视频。也就是说可以传入的不仅只有`<img>`元素,还可以传入`<canvas>`甚至是`<video>`。
你不仅可以把一个图片(或者一部分)绘制[^通过修改w和h进行放缩]到你的画布上，也可以把另一个画布的内容或者当前视频的某一帧当做图片画到你的画布上，样板的浏览地图`core.maps.drawThumbnail`正是使用了这个办法，把新楼层的各个图层画布都画到另一个画布上，达成了绘制楼层缩略图的效果。
x y代表绘制的位置，w h代表绘制的宽高，用法与fillRect相同。设置sx sy sw sh将从图片上选取一部分截取下来绘制，截取部分的位置和坐标由sx sy sw sh决定。

```js
// 红色史莱姆是enemys.png中的第二个怪物 在这里模拟样板绘制这个怪物的过程
// 也是drawIcon的原理
var pos = 1;
core.drawImage("event", core.material.images.enemys, 0, pos * 32, 32, 32, 100, 100, 32, 32)
// ---------->(  name , ------------img----------- , sx, --sy-- , sw, sh,   x,   y,  w,  h)
```

---

#### 在实战开始之前

虽然我们是技术教程(?)，但是光会写脚本是做不成好塔的，更影响作者水平的往往是方法而非工具。
现在我们了解了许多绘制方法进行ui绘制，但在画一个ui前我们首先要做的并不是写代码，而是先有一个大体的设计图，不妨就画出来（或者模仿~~直接抄~~已有作品），既能把握最终成品的样子，在写代码的时候也能让脑子更清醒，如果画了一大堆发现不尽人意再改，就已经浪费许多时间了。

## 实战？

现在我们以楼传为例讲解UI绘制，想想楼层传送的UI，最大的区域被要传送的楼层的地图所占据，上方是一个大标题"楼层传送"，下方是"返回地图"，右侧是当前楼层的名称，右下角有一串小字提示。
我们使用上面提过的方法简单自己写一个类似的UI：

```js
// core.clearMap("all")
// 假设我们的画布是空白的 使用13*13样板
var ctx = core.createCanvas("ui", 0, 0, 416, 416, 100);
core.setAlpha(ctx, 0.8);
core.fillRect(ctx, 0, 0, 416, 416, "gray"); // 绘制背景
core.setAlpha(ctx, 1);

// 使用textAlign能保证"楼层传送"在最中间的位置
core.setTextAlign(ctx, "center");
core.fillText(ctx, "楼层传送", 416 / 2, 50, "#fff", "bold 20px verdana");

core.setTextBaseline(ctx, "bottom");
core.fillText(ctx, "返回游戏", 140, 416 - 20;, "yellow", "17px verdana");

// drawThumbnail是maps.js中的api 用于在某个画布上绘制某个楼层的缩略图
core.drawThumbnail("MT0",null,{ctx: ctx, x: 40, y: 150, size: 200});

// 及时恢复默认值可以防止出现奇怪的错位问题
core.setTextAlign(ctx, "start");
core.setTextBaseline(ctx, "alphabetic");
core.fillText(ctx, "主塔0层", 260, 200,"white");
```

了解了基本的绘制方法后，像楼传这样非常简单的页面我们在几行中就画完了。（鼓掌?
现在看看样板的写法：

```js
ui.prototype.drawFly = function (page) {
    // core.status.event.data是一个类似flags的东西 这里的意思就是存下来当前在哪一页
    core.status.event.data = page;
    
    var floorId = core.floorIds[page];
    var title = core.status.maps[floorId].title; // 获取楼层属性中的title
    core.clearMap('ui');
    core.setAlpha('ui', 0.85);
    core.fillRect('ui', 0, 0, this.PIXEL, this.PIXEL, '#000000');
    core.setAlpha('ui', 1);
    
    // 使用居中对齐把楼层跳跃和返回游戏放到了最中间
    core.setTextAlign('ui', 'center');
    
    // this.HPIXEL是页面大小的一半 13*13就是208
    core.fillText('ui', '楼层跳跃', this.HPIXEL, 60, '#FFFFFF', this._buildFont(28, true));
    core.fillText('ui', '返回游戏', this.HPIXEL, this.PIXEL - 13, null, this._buildFont(15, true))
    core.setTextAlign('ui', 'right');
    core.fillText('ui', '浏览地图时也', this.PIXEL - 10, this.PIXEL - 23, '#aaaaaa', this._buildFont(10, false));
    core.fillText('ui', '可楼层跳跃！', this.PIXEL - 10, this.PIXEL - 11, null, this._buildFont(10, false));
    core.setTextAlign('ui', 'center');

    var middle = this.HPIXEL + 39;
    // 换行
    var lines = core.splitLines('ui', title, 120, this._buildFont(19, true)); // splitLines将一段文字按最大宽度切分成n部分
    var start_y = middle - (lines.length - 1) * 11;
    for (var i in lines) { // 这里的意思就是如果楼层名太长就分成多行写 达成了类似drawTextContent的效果
        core.fillText('ui', lines[i], this.PIXEL - 60, start_y, '#FFFFFF');
        start_y += 22;
    }

    if (core.actions._getNextFlyFloor(1) != page) { // 如果有可飞的上一层就画上 下面同理
        core.fillText('ui', '▲', this.PIXEL - 60, middle - 64, null, this._buildFont(17, false));
        core.fillText('ui', '▲', this.PIXEL - 60, middle - 96);
        core.fillText('ui', '▲', this.PIXEL - 60, middle - 96 - 7);
    }
    if (core.actions._getNextFlyFloor(-1) != page) {
        core.fillText('ui', '▼', this.PIXEL - 60, middle + 64, null, this._buildFont(17, false));
        core.fillText('ui', '▼', this.PIXEL - 60, middle + 96);
        core.fillText('ui', '▼', this.PIXEL - 60, middle + 96 + 7);
    }
    var size = this.PIXEL - 143;
    core.strokeRect('ui', 20, 100, size, size, '#FFFFFF', 2);// 缩略图的边框
    core.drawThumbnail(floorId, null, { ctx: 'ui', x: 20, y: 100, size: size, damage: true });
}
```

完全是常用绘制方法的堆砌，应该不会有看不懂的地方。
绘制UI的同时，往往也需要写界面交互，我们在后面的章节学习。

作业：随便画点东西吧。