# 数组进阶

## 声明定长数组

当你使用 `var a = []` 时，获得的是一个长度为0的数组，如果你希望数组一开始就有一个长度，js提供了一种奇怪的方法

```js
Array(8) // 声明一个长度为8的数组
```

注意 `Array(8, 8)` 的结果则完全不同，它等价于 `[ 8, 8 ]`，为了避免这种问题，如果你想要`Array(8,8)`，用`Array.of(8, 8)` 代替

```js
Array.of(8, 8) // [ 8, 8 ]
Array.of(8) // [ 8 ] 正常返回
```

这个方法令人迷惑的地方不止于此，大多数方法在它身上并不能正常运行，例如说 `Array(8).forEach(console.log)` 一次都不会输出。你需要使用`fill`方法对数组进行填充，之后才能正常使用。

> 不要用这个方法声明二维数组，否则所有的第二维数组都是同一个

```js
var a = Array(2).fill([]);
a[0][0] = 1;
a // [ [1], [1] ] 你要的肯定不是这个
```

暂时不解释这个现象的成因，你可以用`Array(8).fill().map(() => []);`来代替（map在下面会讲到

## 类数组 array-like

在js中，有一些特殊的对象和数组一样有length，并可以使用下标运算符访问元素，例如说之前提过的`arguments`，但是，并不能对他们使用数组的方法，这些对象被称为类数组，在这种情况下，js提供了`Array.from`方法，用于将他们转换为真正的数组对象，例如说：

```js
function mySort() {
    return Array.from(arguments).sort((a, b) => a - b);
}

mySort(1, 5, 4) // [ 1, 4, 5 ]
```

另外一方面来说，如果你希望知道一个变量是否是数组，js提供`isArray`方法，这个方法不能从数组上调用（因为你目前正在确认它是不是数组，而如果它不是数组，则不会有这个方法，，，）

```js
Array.isArray([]) // true

function test() {
    return Array.isArray(arguments);
}
test() // false
```

## 函数式API

从`ECMA2015`开始，JS引入了一系列源于*函数式编程*的数组API，这些API相当强力，但是有一定的理解难度，以下依次进行介绍

### 函数式编程是什么

我们首先从这个概念开始，这会有助于我们抓住本节课的重点

函数式编程是一种编程的范式，爱好函数式编程的人相信，程序可以表达为数学函数——在数学上，函数的返回值只决定于它的参数，例如说`f(x) = x^2 + 2*x + 1`(希望你还记得这是啥)，对于他们来说，程序就是一个巨大的，从输入数据映射到输出的函数。

以下介绍的每个方法都需要传入一个用于变换的函数，这个函数的性质影响了方法本身的用途。

### map 映射

`map`方法的名字并不是地图的意思，而是映射(回想一下，这是一个高中数学概念，实际上，函数式API本身就是脱胎于数学的概念)

这个方法的作用是，对于数组中的每个元素，应用一次传入的函数，并将所有获得的返回值合并为一个新的数组返回。简单来说，它按照一个函数，将一个数组变换为了另外一个数组。

这里的函数更加接近数学上的函数，你可以认为下面的例子中，传入的函数代表`f(x) = x * 2`

```js
[ 1, 2, 3 ].map((x) => x * 2); // 返回 [ 2, 4, 6 ]
```

你也可以获取元素的下标，以及数组本身，不过这并不本质

```js
[ 1, 2, 3 ].map((x, i, arr) => x * i); // 返回 [ 0, 2, 6 ]
```

### filter 过滤

map方法可以将数组进行任意的变换，但是数组的长度始终不变，为了对数组的长度进行修改，js引入了`filter`函数，它可以使用传入的函数来判定一个元素是否需要去除——当函数返回`false`时，这个元素将会被移除，相对的，返回`true`则会保留这个元素。

```js
[ 1, 2, 3 ].filter((x) => x > 2); // [ 3 ] 
```

更多信息参见[mdn文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)

### 折叠的一万种方式 some every reduce reduceRight

filter方法可以修改数组的长度，但是返回的始终是一个数组，这能应付很多场景，但是总有些时候，人们想从数组中抽取一个值，例如说，数组中是否有一个数大于5，也就是说，需要有一种方法，把一个数组折叠为一个任意的量。js提供了一系列折叠的方法，我们先从最简单的开始

#### 任意一个 some

`some` 方法用于检测数组中是否有元素满足条件(也就是说传入的函数返回true)，例如：

```js
[ 2, 4, 6, 8 ].some((x) => x > 5); // true 
```

特别的，对空数组使用`some`总是会返回false

#### 每一个 every

和`some`类似，`every`方法检测是否所有元素都满足条件

```js
[ 2, 4, 6, 8 ].every((x) => x > 5); // false 
```

#### 折叠第三人 find

`find`显然也是一种折叠

#### 一切折叠的本质 reduce

除了上面三个方法，我们总还会有些别的需求，例如说求数组中的最大值（回想一下第3节中我们是如何编写一个`max`函数的），这种情况下，js提供了`reduce`语法，它接收一个特别的函数 `f(r, v)`, 这个函数有两个参数，第一个代表累加值，第二个代表当前元素的值。reduce会将第一个元素作为初始值，从第二个元素开始，每个元素执行一次这个函数，然后将返回值作为下一次的累加值，最后返回累加值

```js
[ 1, 2, 3 ].reduce((r, e) => Math.max(r, e)); // 3

// 你可以这么理解
var arr = [ 1, 2, 3 ];
var r = arr[0];
var f = (r, e) => Math.max(r, e);
for (var i = 1; i < arr.length; i++) {
    r = f(r, arr[i]);
}
```

你也可以自行传入一个初始值，这样的话，可以将累加值变成一个不同于元素类型的值，此时，reduce会从第一个元素开始，每个元素都执行一次传入的函数

```js
[ 1, 2, 3 ].reduce((r, e) => r + e, ""); // '123'

// 你可以这么理解
var arr = [ 1, 2, 3 ];
var r = "";
var f = (r, e) => r + e;
for (var i = 0; i < arr.length; i++) {
    r = f(r, arr[i]);
}
```

你可能会感到疑惑，因为这个方法看起来完全不如直接用`for`循环来的直观，你的感觉是对的，实际上，在这个方法的来源，函数式编程中，用户**不能修改任何变量**，也就是说他们并不能用`for`(你没法修改i)，在这种情况下`reduce`方法被用于代替`for`，既然你在js中可以使用真正的`for`，那么reduce的意义就很微妙了。

> 在真正的函数式语言中，使用折叠的体验反倒没这么差，他们有很多配套的设计来优化使用体验，例如说在`haskell`里你可以直接传入运算符，类似于 `[1, 2, 3].reduce((+))`但是js却不行（所以就更不要在js中用折叠了）
> 如果对这样的语言感兴趣，可以了解一下`haskell`（不过真的很难

#### 从右侧开始折叠 reduceRight

js还提供了`reduceRight`，这个方法与 `reduce` 相似，只是顺序为由右至左

### 链式调用

`map`, `filter`，以及数组基础中讲解的一些方法会返回一个数组，因此你可以连续的调用他们，这种连续进行的调用称为链式调用，是一种非常简洁而容易理解的编程手段。

```js
[ 1, 2, 3, 4, 5, 6, 7, 8 ]
    .map((x) => x * 3 + 1)
    .filter((x) => x % 2 === 0)
    .some((x) => x < 5);
```

## 其他方法

在[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array)中可以看到全部的数组方法，这部分不做要求
