# 第二章 第八节 异步编程

## 异步编程是什么

`异步`这个词听上去有点陌生，实际上它是`同步`的反义词(`synchronized`与`asynchronized`)，我们之前教过的所有语法都是同步的，也就是说，当上一行执行完之后，一定会执行下一行，而不是其他东西，而在异步编程中，这个约定会被打破，这和JS本身的机制有关。

## 基于回调的异步编程

JS采用基于回调的异步编程模型。在这个模型中，异步执行的代码需要被放入一个回调函数中，当事件结束时，回调函数被调用，由此实现异步。我们来看一个简单的例子

```ts
setTimeout(() => {
    console.log("A");
}, 1000);
```

`setTimeout(fn, time)` 是引擎提供的异步函数，它允许你传入一个函数`fn`，以及毫秒数`time`，在指定的毫秒数之后，调用传入的函数。

```ts
setTimeout(() => {
    console.log("A");
}, 1000);
console.log("B");
```

猜猜`A`和`B`哪个先被输出？答案是`B`，因为`A`所在的函数要在一秒后才会被调用。

### 定时器 setInterval

除了`setTimeout`，引擎还提供了另外一个函数`setInterval(fn, time)`，它会每`time`毫秒调用一次传入的函数。

```ts
setInterval(() => {
    console.log("lhjnb");
}, 1000);

// 源源不断的 nb !
```

也许你已经在思考`setTimeout`和`setInterval`内部是如何实现的，不过很遗憾的是它不可能用js实现，它是一个原生函数，需要调用引擎本身的一些能力，所以，把它当作魔法来使用吧。

### 基于异步源的异步编程

在js中，除了`setTimeout`和`setInterval`，还有一些类似的函数会提供异步调用，例如说网络请求，文件读写，或者是监听用户的各种事件（例如点击鼠标），这些函数都由js引擎提供，不过，这并不意味着异步编程只是简单的调用这些函数，通过包装它们，可以完成复杂的功能，例如说。

```js
function beforeChangeFloor() {
    // 在这里编写开始楼层转换后发生的事
    console.log("[开始楼层转换]事件");
}

function afterChangeFloor() {
    // 在这里编写楼层转换完毕后发生的事
    console.log("[楼层转换完毕]事件");
}

function changeFloor(time, callback) {
    beforeChangeFloor();
    setTimeout(() => {
        afterChangeFloor();
        callback();
    }, time)
}

changeFloor(1000, () => {
    console.log("楼层转换完毕");
})

// "[开始楼层转换]事件"
// "[楼层转换完毕]事件"
// "楼层转换完毕"
```

上面举了一个经典的例子：`楼层转换函数`，调用这个函数之后，会依次执行两个函数，然后执行传入的回调。样板中的`core.changeFloor`就是采用这个思路编写的，但是更加复杂，我们将在第四章梳理真实的`core.changeFloor`的执行流程

### 回调地狱

基于回调的异步编程在表达能力上有一定的缺陷，因此在编写某些场景的函数的时候，容易写的非常混乱，这被称为`回调地狱`。

### 其他棘手的场景

以下展示了一个复杂的例子，来自样板的加载资源代码

```js
function loadMod(name, callback) {
    // 在这里异步的加载一个模块，然后调用`callback`
    // ...代码略
}

function loadMods(list, callback) {
    var loaded = 0, total = list.length;
    list.forEach((lib) => {
        loadMod(lib, () => {
            // 这部分代码会在每个模块加载完成之后调用
            loaded++; // 每加载完成一个模块，loaded+1
            if (loaded === total) { // 全部加载完成后调用回调
                callback();
            }
        });
    });
}
```

针对这些场景，有没有办法抽象出公共的部分进行复用？实际上是有的，接下来函数式编程又要开始秀操作了。

## Promise

在`ES2015`中，js从函数式编程语言中引入了`Promise`概念，用来缓解回调地狱的问题。

> `Promise`的中文翻译时`约定`

<!-- 
> 有一个经典的阴间解释，(类似于给萌新推荐血海三原塔级别的阴间)
> `Promise`是一个`monad`，也就是自函子范畴上的幺半群（
 -->

`Promise` 是一个类，它接收一个`函数`作为参数，这个函数会被传入一个函数`resolve`，就像这样

```js
new Promise((resolve) => {
    setTimeout(resolve, 1000);
});
```

当这个传入的函数被`resolve`时，这个`Promise`实例进入`resolved`状态（这个过程是否有点熟悉？`作弊`那题的judge函数就是这么套娃的），或者可以称这个`Promise`被完成了。

你可以对一个`Promise`调用`then`方法，这个方法同样接收一个函数，这个函数会在`Promise`完成时调用，如果`Promise`已经完成，则会立即被调用，就像这样

```js
const p = new Promise((resolve) => {
    setTimeout(resolve, 1000);
});
p.then(() => {
    console.log("1000毫秒后");
    p.then(() => {
        console.log("这个函数会被立即调用，因为p已经被完成了");
    })
});
```

### 携带一个值

在调用`resolve`函数的时候，你可以向其中传入一个值，这个值会被保存在`promise`中，在调用`then`时，你可以在回调函数中以参数的形式获取这个值

```js
const p = new Promise((resolve) => {
    setTimeout(() => resolve(5), 1000);
});
p.then((value) => {
    console.log(value); // 5
});
```

### then的返回值

实际上`then`方法也是有返回值的，而这个返回值也是一个`Promise`，特别的，如果`then`的回调函数返回了一个值，这个值将作为返回的新`Promise`的携带值

```js
const p = new Promise((resolve) => {
    setTimeout(() => resolve(5), 1000);
});
p.then((value) => {
    console.log(value); // 5
    return value * 2;
}).then((value) => {
    console.log(value); // 10
});
```

接下来是非常神奇的时刻，如果返回的值是另外一个`Promise`，会发生什么情况呢

```js
const p = new Promise((resolve) => {
    setTimeout(() => resolve(5), 1000);
});
p.then((value) => {
    console.log(value); // 5
    return new Promise((resolve) => {
        setTimeout(() => resolve(value * 2), 1000);
    });
}).then((value) => {
    console.log(value); // 10
});
```

奇妙的是，下一个`then`拿到的值仍然是`10`，而不是`Promise`，也就是说不管嵌套了多少层`Promise`，`then`都会进行解套，取出真正的嵌套值。

想必你已经想到，这个表现意味着，下一个`then`中的代码会依次等待原先的`Promise`和上一个`then`中的`Promise`，这个特性可以被用于改写回调地狱。

### 用Promise改写回调地狱

如下所示，我们可以把嵌套的回调改写为`then`的链式调用，另外，我们还可以返回其他的`promise`，以并行的等待两个`Promise`

```js
function sleep(time) {
    return new Promise((resolve) => {
        setTimeout(resolve, time);
    });
}
const p0 = sleep(3000);
sleep(1000)
    .then(() => {
        console.log("1000毫秒后");
        return sleep(500);
    }).then(() => {
        console.log("1500毫秒后");
        return p0;
    }).then(() => {
        console.log("3000毫秒后");
    });
```

### Promise.all

`Promise`还提供了一个额外的静态方法`Promise.all`，用于将一个`Promise`数组合并为一个`Promise`，我们尝试用这个方法改写loadMod

```js
function loadMod(name, callback) {
    // 在这里异步的加载一个模块，然后调用`callback`
    // ...代码略
}

function loadMods(list, callback) {
    Promise.all(list.map((lib) => {
        return new Promise((resolve) => {
            loadMod(lib, resolve);
        })
    })).then(() => {
        callback();
    });
}
```

`Promise`提供了非常有力的处理异步编程的方案，现代JS库基本都将传入回调函数的异步方法改写为返回`Promise`的形式。不过，作为使用过事件的人，你应该会发现这种方案仍然比事件难用很多，有没有办法用符合直觉的同步形式，而不是回调来进行异步编程呢，实际上js后面也引入了这种方案。

## async / await

在`ES2017`中，js引入了威力无比的`async` / `await`关键字，这使得回调地狱几乎彻底被解决。

一个简单的`async` / `await`例子如下所示

```js
function sleep(time) {
    return new Promise((resolve) => {
        setTimeout(resolve, time);
    });
}
async function sleep2() {
    await sleep(1000);
    console.log("1000毫秒后");
    await sleep(500);
    console.log("1500毫秒后");
}
sleep2();
```

简单来说，`async` 和 `await` 是成对使用的关键字，你可以在函数声明前加入`async`将其转变为一个`async`函数，在`async`函数中，你可以在函数调用前加上`await`关键字，如果这个函数返回了一个`Promise`，那后续的代码会在该`Promise`完成后执行。相对的，这个函数的返回值会自动套上一层`Promise`，因为它实质上并非同步执行，不可能立即返回值。

在`async`函数中，除了顺序执行，你也可以以符合直觉的方式在`if`和`while`, `for`块中使用`await`。下面给出一个例子；

```js
async function lazySleep(lazy) {
    await sleep(1000);
    console.log("1000毫秒后");
    if (lazy) {
        await sleep(1000);
        console.log("2000毫秒后");
    }
    console.log("起了起了");
}
lazySleep(false);
```

## 滥用await

`async` / `await`是如此的方便，以至于人们会习惯性的在任何地方使用它，但是它也会带来一些隐式的问题，因此要小心滥用。例如说下面这个例子——我们用`async` / `await`改写了`loadMods`函数，现在它看起来前所未有的简单。不过这其中也隐含着问题。

```js
async function loadModAsync(name) {
    // 在这里异步的加载一个模块
    // ...代码略
}

async function loadModsAsync(list) {
    for (var lib of list) {
        await loadModAsync(lib);
    }
}
```

在`for`中使用`await`是非常美妙的，但是要注意这会使每次循环都要等待上一轮结束才会进行，这意味着我们只能一个个串行的加载模块，而在加载时，并行总是会比串行快一些。

一般情况下，可以用`Promise.all`来代替循环。比如说下图的改写。

```js
async function loadModAsync(name) {
    // 在这里异步的加载一个模块
    // ...代码略
}

async function loadModsAsync(list) {
    await Promise.all(list.map((lib) => loadModAsync(lib)));
}
```
