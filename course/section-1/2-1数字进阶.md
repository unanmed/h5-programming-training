# 第二章 第一节 深入了解数字

本节课我们会系统性的学习数字

## 数字的表示方法

### 朴素的数字

你可以使用最朴素的方法来表示数字——就好像你写数学作业的时候做的那样

```js
1
-1
0.1
.1 // 与上面一个相同 
```

### 科学计数法

如果读者上过高中的话，应该已经接触过科学记数法，或者也可以参考[百度百科](https://baike.baidu.com/item/%E7%A7%91%E5%AD%A6%E8%AE%B0%E6%95%B0%E6%B3%95/1612882)。在表示较大的数字时，科学记数法非常好用，这能使你非常容易感知到数字的量级区别 (可以尝试速算1123412341234/712412343，相比之下，1.12e+12 / 7.12e+8 能得到得数的大概大小)

```js
1e10 // 就是1*10^10
2.23423e+123 // 就是2.23423*10^123
6.14364e-7 // 就是6.14364*10^-7
```

### 2进制和16进制

在特别的情况下，需要使用其他的进制来表达数字（例如说，二进制串可以当成一连串的布尔值使用，而在表示颜色的时候常用16进制字符串，也许你听说过`#66CCFF`），js提供了2进制和16进制的字面量表示方法，你可以使用`0b`/`0B`开头的数字串来表示二进制(b = binary，即`二进制`)，用`0x`/`0X`开头的字符串表示16进制串(x = hexadecimal 即`十六进制`)

```js
0b1 + 0b1 === 0b10 // true 典中典之 1+1 = 10 
-0b1 // 负号是加在最前面的
0x7F // = 127
0xFf // 可以混用大小写，但是小心被强迫症打（
```

除了以上这些数字之外，js 中的数字还包含两个特别的字面量，`NaN` 和 `Infinity` 

### NaN

`NaN`是`Not a Number`的缩写，在早期 `flash` 游戏里这是一个很常见的量，它是数字运算出现错误的征兆。

#### 产生 NaN

一个最常见的 `NaN` 出现原因是产生了除0错误：

```js
0 / 0 // NaN
```

一些内置的处理函数也会返回 `NaN`，我们将在本节的后续部分见到它们。

另外一个巨大的产生源则是 `NaN` 的传染，将 `NaN` 和任何数运算都会得到 `NaN`，像这样：

```js
0 + NaN // NaN
NaN + NaN // NaN
```

#### 判断是否为 NaN

绝大多数时候，`NaN` 不是我们想要的结果，因此判断 `NaN` 非常重要，但是很不幸的是，`NaN === NaN` 是不成立的，因此这么做不会奏效：

```js
var a = NaN;
if (a === NaN) {
    console.log("运算出错"); // 这并不会被执行
}
```

与之相对，js 提供了一个函数 `Number.isNaN` 来判断一个数值是否是 `NaN`，像这样：

我们可以通过一个函数判断一个内容是否是NaN（不能使用 `number === NaN`，因为`NaN !== NaN`）

```js
Number.isNaN(NaN); // true
Number.isNaN("mota.pw"); // false
```

> 曾经有另外一个函数 `isNaN` ，它的名字看起来更短，但是不幸的是它对上面的第二种情况会返回 true，因此被弃用了。

### Infinity

顾名思义，`Infinity` 就是无限大。在 js 中，数字的大小并不是无限的，如果某个数字的值超过一个特定的常量 `Number.MAX_VALUE`，它的值就会变成 `Infinity`，例如说这样：

```js
1e100000 // Infinity
```

相对的，也存在`-Infinity`，小于 `-Number.MAX_VALUE` 的值就会变为 `-Infinity`

```js
-1e100000 // -Infinity
```

类似 `NaN`，`Infinity` 也拥有传染性，像这样：

```js
Infinity + 10 // Infinity
Infinity + Infinity // Infinity

Infinity - 10 // Infinity
10 - Infinity // -Infinity

Infinity * 10 // Infinity
Infinity * -10 // -Infinity

Infinity / 10 // Infinity
Infinity / -10 // -Infinity
```

不过，存在两种特殊的运算结果：

1. `Infinity - Infinity` 结果为 `NaN`
2. `任何数 / Infinity` 结果都为 0，特别的，`Infinity / Infinity` 为 `NaN`

## 数字的内置函数

js 提供了一些内置的数字方法，你可以以 `数字.xxx()` 的形式调用它们，例如说这样：

```js
var a = 5;
a.toString(); // "5"
```

对于字面量，你需要在数字外加一层括号才能正常调用，因为编译器难以判断`.`是否是小数点：

```js
(5).toString(); // "5"
```

### toString

`toString` 这个方法可以将数字转化为字符串。方法有一个可选的参数，可以指定输出进制，范围是`2~36`，默认为十进制

```js
var a = 12345;
a.toString(); // "12345"
a.toString(2); // "11000000111001"
a.toString(16); // "3039"
```

### toExponential

`toExponential` 方法可以将数字转化为科学计数法形式的字符串，并以字符串的形式返回。方法有一个参数，指定小数部分精确位数，末位四舍五入

```js
(123).toExponential(); // "1.23e+2"
(123).toExponential(1); // "1.2e+2"
```

### toFixed

`toFixed` 方法会将数字转化为指定位数的小数的字符串，四舍五入末位，并以字符串形式返回。方法有一个参数，指定要精确的位数，范围是`0~100`，默认为 0

```js
(123.456789).toFixed(); // "123"
(123.456789).toFixed(3); // "123.457"
```

## Math 内置数学工具

除了内置函数外，js 还提供了一系列用于数学运算的工具，你可以以 `Math.xxx` 的形式使用它们，以下简单的介绍一遍：

### 内置数学常量

为了方便计算，Math 中包含了一些常见的数学常量，如下：

```js
Math.PI // 3.141592653589793 显然这是圆周率
Math.E // 2.718281828459045 自然常数
Math.SQRT2 // 1.4142135623730951 根号二
Math.SQRT1_2 // 0.7071067811865476 根号二分之一
```

### 数学运算

除了常量之外，js 提供了一组用于数学运算的函数，我们在计算器上应该见过这些，所以就只简要介绍下：

```js
Math.pow(x, y) // 返回 `x ** y` 的结果
Math.sqrt(num) // 返回传入数字的平方根
Math.cbrt(num) // 返回立方根
Math.abs(num)  // 返回绝对值
Math.sign(num) // 返回数字的符号，负数返回`-1`，0返回`0`，正数返回`1`
```

除此之外也有三角函数相关的各种运算，要特别的注意的是，它们是使用弧度制的，也就是说，`Math.PI` 相当于 180 度：

```js 
Math.sin(Math.PI / 2) // 1
Math.cos(0) // 1
Math.tan(0) // 0
```

除了这三个外，还有其反函数，此处不再赘述，留个印象即可。

### 取整

Math 提供了多达四个函数用以执行不同的取整操作，一个常见的取整策略是直接抛弃小数部分，在这种情况下，你可以使用 `Math.trunc`，效果如下：

```js
Math.trunc(0.5) // 0
Math.trunc(-1.7) // -1
```

> trunc 即 truncate 的简写，意为 `截断`

js 还提供了一个非常相似的方法 `Math.floor`，这个方法使用`下取整`的策略，也就是说数字总会舍入到比它小的最接近整数，在处理正数时，这个策略与`截断`相同，而处理负数时结果则恰相反，示例如下：

```js
Math.floor(0.5) // 0
Math.floor(-1.7) // -2
```

（在买入物品时，人们总希望对物品价格进行这个操作）

与之相对的，`Math.ceil` 方法使用`上取整`的策略，数字总会舍入到比它大的最小整数，像这样：

```js
Math.ceil(0.5) // 1
Math.ceil(-1.7) // -1
```

> floor 和 ceil 分别是 地板 和 天花板 的意思

最后一种常见的策略是四舍五入，它对应的方法是 `Math.round`，我们很熟悉它在处理正数时的规则：

```js
Math.round(0.49) // 0
Math.round(0.5) // 1
Math.round(0.51) // 1
```

不过，在处理负数时，这个函数会特别的对待 `.5`，这个值会向上取整

```js
Math.round(-1.49) // -1
Math.round(-1.5) // -1
Math.round(-1.51) // -2
```

### 随机数

`Math.random` 方法能返回一个 0 到 1 之间的数，具体来说，返回值属于 `[0, 1)`（也就是说，返回值包含0，但是不包含1），像这样：

```js
Math.random() // 0.114514 0.1919810 ... 总之一切皆有可能
```

如果你需要其他区间中的随机数，例如说你希望生成 1 ~ 6 中的任意一个整数，就需要处理一下输入了，大概的思路如下：

```js
Math.random(); // [ 0, 1 )
Math.random() * 6; // [ 0, 6 )
1 + (Math.random() * 6); // [ 1, 7 )
Math.floor(1 + (Math.random() * 6));
```

### 最大 / 最小值

要介绍的最后一组函数是取多个数的最大值 / 最小值，js 提供了 `Math.max` 和 `Math.min` 用于完成这个功能，你可以传入任意多数量的参数，返回值会是其中的最大 / 最小数。

```js
Math.max(1, 2) // 2
Math.max(1, 2, 3) // 3
Math.min(1, 2) // 1
Math.min(1) // 1
```

特别的，如果我们一个参数都不传，会发生什么？不妨一试：

```js
Math.max() // -Infinity
```

结果居然是 `-Infinity`，网上有一个 js 笑话合集，将这个结果认为是 js 的设计失误，不过实际上这只能证明笑话编篡者的知识浅薄。如果读者有离散数学的基础，应该会发现`-Infinity`是 `max` 运算的 `幺元`，也就是说，对于任何一个数`x`，总有 `x === Math.max(-Infinity, x)`，这使得`-Infinity`可以作为不定多参数执行`max`运算的初始值。

## 数字的内部表示方法

### 二进制表示与位运算

众所周知，计算机内部使用二进制来表示数字，因此我们不难想象，`2`在计算机中被表示为`10`。而直接针对二进制位来进行运算的方法被称为位运算，我们在第一节课已经接触过位运算的操作符，即`>>`, `<<`, `|`, `&`, `^`, `~`, 以及相应的赋值符号，接下来我们一一解释其用途。

首先是 `<<` 和 `>>` 这两个运算符被称为左移/右移运算符，顾名思义，是将一个数的二进制表示的位进行左移/右移，对于右移的情况，最右侧的一位会消失，一些情况下，`>> 1` 会当作`用2整除`使用

```js
2 >> 1 // 1 (10 -> 1)
3 >> 1 // 1 (11 -> 1)
2 << 1 // 4 (10 -> 100)
```

`|`运算符被称为`按位或`，这个运算符可以将两个数按照它们的二进制表示，一位一位进行`或`的运算，也就是说，两个数中任何一个数的某一位是`1`则结果的这一位就是`1`

```js
1 | 2 // 3 (1 | 10 -> 11)
```

`&`运算符被称为`按位与`，这个运算符可以将两个数按照它们的二进制表示，一位一位进行`与`的运算，也就是说，两个数的某一位都是`1`则结果的这一位才是`1`

```js
3 & 2 // 2 (11 & 10 -> 10)
```

`^`运算符被称为`异或`运算符，这个运算符可以将两个数按照它们的二进制，一位一位进行`异或`的运算（也许你玩过一个叫[异或之](https://h5mota.com/tower/?name=xor)的塔），`异或`的意思是，两个数的某一位不同，则结果中的这一位为`1`

```js
3 ^ 2 // 1 (11 ^ 10 -> 1)
```

`~`运算符被称为`取反`运算符，这个运算符可以将一个数的所有二进制位翻转，因此你对`1`进行取反会得到。。。`-2`！这里面包含了更加深奥的知识，我们将借此彻底明白 js 中数的存储方式。

### 整数的内部存储方式

也许你已经注意到我们刚刚没有谈负数的事情，实际上，现代计算机往往采用一种叫做二进制补码的方式表示整数，在这套系统中，一个数由固定数量的二进制位表示，特别的，最高位作为符号位，最高位为`0`的数表示非负数，我们以4位二进制数作为例子，像这样：

```
0000  (0)
0001  (1)
```

而最高位为`1`的数则表述负数，但是，`-1` 并不是 `1001`，而是`1111`，这有个隐含的好处：对于计算机来说，正数和负数的顺序是一样的，在进行加减运算时，计算机可以不考虑符号位，进行相同的操作，减少逻辑的复杂性，降低电路成本。

```
1111 (-1)
1110 (-2)
```

特别的，在 js 中，进行位运算时将使用 `32`个二进制位表达数字，因此一旦你使用这几个运算符，你的数就会转换为`32`位数，因此对于大于`2^31-1`或者小于`2^31`的数，得到的结果不会如你所愿。

让我们回到取反，现在应该能够明白 `~1 === -2` 的原因了，取反前后的实际位情况如下：

```
00000000 00000000 00000000 00000001  (1)
11111111 11111111 11111111 11111110  (-2)
```

这个操作符有两个常见用途，一个是`~-1`，以获得0（很多api会将-1作为错误结果，但是只有0能转换为false）另外一个用途是，将数字取整：`~~1.1`（注意到一个数取反两次就等于它本身）不过这有一些限制，如果数字过大或过小，会产生意外的损失，像这样：

```js
var qq = 14538086561;
~~qq; // 1653184673
```

### 逻辑尺

一个位运算的常见应用是`逻辑尺`，其大概意思是，用一个整数来表示多个布尔量，结合位运算，这可以简单的处理各种判断，我们展示一个简单的逻辑尺示例：

```js
// 首先声明一系列的属性，每个属性是正好仅有一位为 1 的数字，彼此之间错开
var HAS_MAGIC = 1 << 0;   // 001
var HAS_POISON = 1 << 1;  // 010
var HAS_IMITATE = 1 << 2; // 100
var enemy = 0b101;
// 使用 & 可以判断怪物是否拥有某个属性
if (enemy & HAS_MAGIC) {
    console.log("是魔攻");
}
// 使用 | 也能达到类似的效果
if (enemy | HAS_POISON === enemy) {
    console.log("是中毒，麻")
}
```

使用 `&` 判断怪物拥有某个属性是一个有趣的技巧，注意到与属性值进行 `&` 运算后，除了属性那一位之外的其他位都会置零，因此运算后的数值只可能是 0 或者 对应的属性值，使用 `|` 运算的实际过程与此类似，读者可以自行思考。

修改逻辑尺的值同样也是使用这几个方法

```js
var enemy2 = 0b000;
if (enemy2 & HAS_MAGIC) {
    console.log("是魔攻"); // 不会有效
}
enemy2 |= HAS_MAGIC;
if (enemy2 & HAS_MAGIC) {
    console.log("是魔攻"); // 起效
}
enemy2 &= (enemy2 ^ HAS_MAGIC);
if (enemy2 & HAS_MAGIC) {
    console.log("是魔攻"); // 不起效
}
```

你也可以同时处理多个属性，注意到这时候 `&` 和 `|` 两种判断方法效果不同，`&` 在拥有任一属性时即满足，但是`|`则要求拥有所有属性：

```js
var enemy3 = 0b000;
enemy3 |= (HAS_MAGIC | HAS_IMITATE);
if (enemy3 & (HAS_MAGIC | HAS_POISON)) {
    console.log("是中毒或模仿，太缺德了"); // 有效
}
if (enemy3 | (HAS_MAGIC | HAS_IMITATE) === enemy3) {
    console.log("是模仿魔攻，太缺德了"); // 同样有效
}
```

> 也许你对这部分内容感到很迷惑，不过不用担心，这组API在实际开发中很少用到，它们是来自C语言的遗留，所以就像C语言一样，暴露了大量的计算机本质，高性能，但是难以使用。

### 浮点数及其表示限制

很明显，上面写的这种方法只能用来表示整数，人们要如何用二进制来表示小数呢？一种常见的方案是将数以科学计数法形式表示，这种方案被称为浮点数，因为它的小数点位置会变化。js使用的浮点数标准为`IEEE754 双精度浮点数`，`IEEE`是国际电子电气组织，双精度则是指它使用`64`位——即两个`32`位存储单元，进行存储。具体来说，其中`52`个位用于表示有效数字，`11`个位被用于表示幂（特别的，计算机使用2为底的幂次，而不是10），范围为`2^(-1022)~2^1023`），剩下一个用来表示正负。

网上流传着一个经典的js大坑：`0.1 + 0.2 !== 0.3`，学过本节之后我们不难理解其原理：浮点数的分母是`2`的倍数，而`0.1`, `0.2`, `0.3`的分数形式中包含因子`5`，因此无法被准确表示。（实际上，大多数语言都使用和js同款的浮点数标准，因此这是个普遍性问题）

除此之外，我们还可以知道其表示的限制，JS提供了三个可访问的常数 `Number.MAX_VALUE`,代表浮点数能表示的最大值，`Number.MIN_VALUE` 代表浮点数能表示的最小**精度**, `Number.MAX_SAFE_INTEGER` 代表浮点数能安全表示的最大整数，超过这个限制之后，多个整数会被表示为相同的值，例如说 `2 ** 1023 + 1 === 2 ** 1023`，可能会发生一些奇怪的错误

```js
Number.MAX_VALUE // 1.7976931348623157e+308 即 `2^1024 - 2^(1024-53)` 
Number.MIN_VALUE // 5e-324 即 `2^(-1022-52)`
Number.MAX_SAFE_INTEGER // `-2^53+1`~`2^53-1` 因为分子只有52个位，再加上一个符号位于是是53位
```
