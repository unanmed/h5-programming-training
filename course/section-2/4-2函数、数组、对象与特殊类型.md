# 第四章 第二节 函数、数组、对象与特殊类型

在上一节，我们了解了ts中的几种基础类型，在这一节我们会更加深入地探讨ts的类型系统

## 特殊类型

在ts中有以下几种常见的特殊类型：`void` `null` `never` `any`，我们一一进行说明

### void 

空类型，常用于函数的返回值（之后会讲），只能转变为`undefined`或`null`，这意味着它相当于`undefined | null`，但与之又不完全一样。我们知道，在不开严格模式的情况下，可以直接使用未定义的变量，而在严格模式下却不行，因为未定义的变量并不是`undefined`，而是一种与之类似的空类型。就好比我们声明一个对象，一个为`undefined`的属性与不存在的属性并不相同一样。这个现象在数组中也有体现，比如我们用`const arr = new Array(40)`，就会声明一个有40个空元素的数组，输出到控制台，控制台并不会显示40个`undefined`，而是40个`空`。这就是`void`与`undefined | null`的区别

### null

我们知道，在js中，`null`的类型是`object`，但是在ts中，有一个特殊的类型`null`专门用来表示`null`，所以如果要表示`null`，请不要将该变量或其他东西的类型设为`object`，而是`null`

### never

`never`是一种非常特殊的类型，它表示不可能会存在的类型，常见于函数的返回值（当然如果你的函数返回值出现了这个，那么大概率你的函数有问题），之后在函数一节会详细讲述

### any

`any`表示任意值，这意味着当ts遇到它时，会直接忽略类型检查，因此其有一定的风险，但在有时候，我们不得不使用它，比如样板的某些神秘属性

## 数组

说了这么多，我们还没有提过引用类型的类型标注怎么解决，那么就让我们从数组开始（因为数组相对简单一些）

声明数组类型有两种方法：`(类型)[]`或`Array<类型>`，可以根据自己的习惯选择自己喜欢的方法。

```ts
const arr1: string[] = ['lhjnb'];
const arr2: Array<string> = ['h5nb'];
```

对于多维数组，我们也使用类似的方式

```ts
const arr1: string[][] = [['lhjnb'], ['h5nb']];
const arr2: Array<Array<string>> = [['lhjnb'], ['h5nb']];
```

## 元组

元组可以认为是数组的一种，可以声明某个数组的特定项的类型，形式为`[第一项的类型, 第二项的类型, ...]`

```ts
const arr1: [number, string] = [1, 'h5'];
const arr2: [number, string][] = [[1, 'h5'], [2, 'lhj']];
```

## 可选类型

有时候，我们会遇到某个元素可以有也可以没有的情况，我们就需要可选类型，格式为`类型?`，注意必选类型必须在可选类型前

例如，我们在元组中使用可选类型

```ts
const arr: [number, string?][] = [[1, 'lhjnb'], [2]];
```

## 对象

对象是js的最主要的数据类型，类型标注也相应复杂一些

### 属性

对于一个特定的属性，我们使用`属性名:类型`的形式，可选属性使用`属性名?:类型`的形式

```ts
const obj: {
    name: string
    sex: string
    age?: number
} = {
    name: 'lhj'
    sex: 'god'
}
```

当然，对象里面还可以套对象

```ts
const obj: {
    name: string
    age?: number
    data: {
        address?: string
        ID: string
    }
} = {
    name: '鹿神',
    data: {
        ID: 1356
    }
}
```

### 索引类型

很多时候，我们会遇到这么一种情况：我不知道对象里面有啥属性，但我可以保证每个属性都是同一种类型或少数几种类型，这时候我们显然不能全部列举。因此，ts中便有了索引类型

索引类型的格式为`{ [x: string | number | symbol]: 类型 }`

其中的`x`可换为其他单词，其类型可在上面列举的三种中选择

```ts
const obj: { [x: string]: string } = {
    MT1: '第一层',
    MT2: '第二层',
    MT3: '第三层'
}
```

### 索引类型+属性

我们也可以在使用索引类型的时候设置特定属性的类型，但是必须保证特定属性满足索引类型

```ts
const obj: { 
    MT1: string
    MT2: number // 不允许出现，因为number不是string，与索引类型不符
    3: string // 不允许出现，因为3是number类型，而索引类型明确标明索引是字符串
    [x: string]: string 
}
```

### 使用别名

很多时候对象的类型会很长，所以我们可以使用类型别名

## 函数

函数的类型标注是ts中最为复杂的，涉及到很多方面，同时善用也可以出奇效

### 参数、返回值

在ts中，函数的参数必须标明类型，返回值不做硬性要求。声明方式如下

```ts
function add(a: number, b?: number): number { return a + (b ?? 0); }
```

其中`a`是必选参数，`b`是可选参数，可选参数只需要在参数名后面加一个问号即可，返回值是number。当然我们也可以不写number，因为`a`和`b`都是number，那么它们相加后的结果也一定是number，所以ts可以帮我们推断出其返回值为number

如果函数没有返回值，那么返回值就是void，即空返回值

### 参数默认值

在上述例子中，`b`是可选参数，因此在处理时需要特判是否被传入。在上述例子中，我们使用了`??`运算符来判断，但是显然这是很啰嗦的。为此，我们可以使用参数默认值

```ts
function add(a: number, b: number = 0) { return a + b; }
```

这样，我们可以很清楚地看出，`b`的默认值为0，只要传入`undefined`或`null`，那么`b`就会变成0。注意，如果设置了默认值，这个参数一定会变成可选参数，不能在参数名后面加问号。

在js中也支持上述语法

### 扩散运算符

在函数中使用扩散运算符时，参数会被认为是一个数组，因此类型标注要求是数组类型

```ts
function add(...nums: number[]) { return nums.reduce((curr, v) => curr + v) }
function add(...nums: number[]): number { return eval(nums.join`+`) } // 神秘的写法，千万不要学
```