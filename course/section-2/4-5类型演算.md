# 第五节 类型演算

## 类型演算

如果你已经接受了上面的内容，那么我们不妨突进一下想象力，既然函数，接口和类可以使用泛型，也许 `type` 也可以，实际上的确如此，而且这个操作的后果远超想象，例如说，ts 内置了这样的 Type：

```ts
interface Option {
    prop1: number;
    prop2: number;
}
let i: Partial<Option> = { prop1: 1 }; // Partial<Option>
```

这个 `Partial` 类型的作用是，将一个对象的所有属性都变成可选的，也就是说，i 实际的类型像是这样：

```ts
interface Partial_Option {
    prop1?: number;
    prop2?: number;
}
```

通过上述泛型的学习，你可能会意识到，`Partial`的本质就是：

```ts
type Partial<T> = {
    [P in keyof T]?: T[P]
}
```

除了`Partial`这个东西，ts 本身还为我们提供了这些东西：

### Required

它可以让一个对象中的所有项都变成必选的：

```ts
interface Option {
    prop1?: number;
    prop2?: number;
}
let i: Required<Option> = { prop1: 1, prop2: 2 }; // 所有项都必选
```

它的本质是

```ts
type Required<T> = {
    [P in keyof T]-?: T[P] 
}
```

### Readonly

将所有项变成只读的，本质是：

```ts
type Readonly<T> = {
    readonly [P in keyof T]: T
}
```

### Pick

从一个对象中挑选出一些项拿出来：

```ts
type A = {
    num: number
    str: string
    bool: boolean
}

type B = Pick<A, 'num' | 'str'>

//// B的类型就是：

type B = {
    num: number
    str: string
}
```

### Record

类似于映射类型

```ts
type A = Record<'a' | 'b', number>

//// 等价于

type A = {
    [T in 'a' | 'b']: number
}
```

本质：

```ts
type Record<K extends keyof any, T> = {
    [P in K]: T;
}
```

### NonNullable

除去类型中的undefined和null

```ts
type A = NonNullable<number | undefined> // A的类型是number
```

本质：

```ts
type NonNullable<T> = T & {}
```

因为null和undefined上面没有属性，所以会被剔除掉，这个有点难理解

### extends 表达式

这里的extends与泛型的extends不同，在这里，extends用于判断一个类型是否可以分配给另一个类型，它一定以三元表达式的形式出现：

```ts
type A = number

type B = A extends number ? true : never
```

这里，B的意思是，如果A的类型可以分配给number，那么B的类型就是true，否则就是never。在对联合类型使用此操作时，ts会将联合类型展开并逐个进行比对：

```ts
type A = 'a' | 'b' | 'c' | 1 | 2

type B = A extends string ? A : never
```

这里，A的五个类型会逐个判断是否可以分配给string类型，然后将每个判断结果整合成一个新的联合类型。因此，B的类型为`'a' | 'b' | 'c'`

有了extends表达式，我们又可以干一些有意思的事情：

### Extract

从一个类型中选择一部分类型，正如我们上面的那个例子

```ts
type A = Exclude<'a' | 'b' | 'c' | 1 | 2, string> // 'a' | 'b' | 'c'
```

本质：

```ts
type Extract<T, U> = T extends U ? T : never
```

### Exclude

从一个类型中剔除一部分类型，与Extract正好相反

```ts
type A = Exclude<'a' | 'b' | 'c' | 1 | 2, string> // 1 | 2
```

本质：

```ts
type Exclude<T, U> = T extends U ? never : T
```

### Omit

从一个对象中剔除一部分属性，与Pick相反

```ts
type A = {
    num: number
    str: string
    bool: boolean
}

type B = Omit<A, 'bool' | 'num'> // { str: string }
```

本质：

```ts
type Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>
```

### typeof

表示获得某个变量或常量的类型

```ts
const arr = [1, 2, 3];
type A = typeof arr // number[]
```

### infer

infer是一个很难理解的东西，也不是很常用，但在某些地方有很大的用途。它一定在extends后出现，这意味着它也一定伴随着三元表达式出现。它表示推断extends之前对应位置的类型，并生成一个推断类型，在之后可以使用它。如果推断成功，就会返回:之前的类型，否则就是:之后的类型。这么说可能不好理解，我们先看一个例子：

```ts
type A = number

type B = A extends infer P ? P : never
```

这个是什么意思呢？我们这样理解，首先infer表示推断与extends前相同位置的类型，那么P的类型就是A了，因为推断成功，所以B的类型就是P，也就是A，也就是number。下面我们看一个稍微复杂的例子：

```ts
const arr = [1, 2, 3];

type A = typeof arr

type B = A extends Array<infer P> ? Record<number, P> : any
```

我们从上面知道了infer可以直接推断类型，但除此之外，它还能推导泛型，正如上面的例子。首先arr是一个数组，它的类型是`number[]`，也就是`Array<number>`，从上面的描述中我们知道，infer用于推断对应位置的类型，因此infer就会推断`Array<这里的类型>`，然后把类型赋给P。很显然，上述例子中的推断是成立的，因此B的类型就是`Record<number, P>`，推断出的P的类型是number，因此B的类型就是`Record<number, number>`

### is

is是只能在函数返回值中出现的运算符，它用于判断一个参数是否是一个类型。例如：

```ts
function has<T>(value: T): value is NonNullable<T>
```

它的返回值是一个布尔型。当然，ts不管你是怎么实现的，只要返回值是一个布尔型就能通过类型检查。它的返回值表示`value`是否是将`undefined`排除后的`T`，这意味着这个函数可以用于判断一个量是否一定存在：

```ts
function fn(v?: number) {
    if (has(v)) {
        // 这里是当v存在的时候
    } else {
        // 这里是当v不存在的时候
    }
}
```

有了infer和is，我们就可以创造出来一个更为奇妙的东西

### Parameters

用于获得一个函数的所有参数：

```ts
function toArray(...args: number[]): number[]

type A = Parameters<typeof toArray> // number[]

function toArray2(a: number, b: string): [number, string]

type B = Parameters<typeof toArray2> // [a: number, b: string]
```

本质：

```ts
type Parameters<T extends (...args: any) => any> = T extends (...args: infer P) => any ? P : never
```

### ReturnType

用于获取一个函数的返回值

```ts
function test(a: any, b: any): boolean

type A = ReturnType<typeof test> // boolean
```

本质：

```ts
type ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : any
```

### 模板字符串

通过上述的教学，我们发现ts处理字符串的能力很弱。为此，ts还提供了一个模板字符串的功能，它能让字符串之间相互组合：

```ts
type A = '1' | '2' | '3' | '4'

type B = 'a' | 'b' | 'c' | 'd'

type C = `${B},${A}` // 包含了B和A的所有16种组合
```

### 字符串处理

ts内置了四种能够处理字符串的类型：

1. `Uppercase<S extends string>`把字符串变成大写
2. `Lowercase<S extends string>`把字符串变成小写
3. `Capitalize<S extends string>`把首字母变成大写
4. `Uncapitalize<S extends string>`把首字母变成小写

由于这些类型很难或不能使用ts的类型演算做到，因此它们都使用了ts的内置处理工具进行处理

### as

在映射类型中，你还可以使用as进行重分配类型，例如：

```ts
type Getters<T> = {
    [P in keyof T as `get${Capitalize<string & P>}`]: () => T[P]
}; // 这里将P重新分配给了`get${Capitalize<string & P>}`，也就是说，如果P的类型是'name'，那么重新分配后的类型就是getName，
// 那么也就是说Getters的所有属性名都会是  get+首字母大写的原来的属性名
 
interface Person {
    name: string;
    age: number;
    location: string;
}
 
type LazyPerson = Getters<Person>;
// 结果：
// type LazyPerson = {
//     getName: () => string;
//     getAge: () => number;
//     getLocation: () => string;
// }
```

### new

上面说过，映射类型不能直接用于类和接口的第一级，接口可以用type代替，但是类没有可以代替的。为此，我们可以使用`new`运算符来实现。`new`运算符用于声明一个构造函数：

```ts
type Constructor = new (...args: any) => {}
```

你会发现它可以声明一个返回值，那么这不就是说我们可以在里面使用映射类型了！

```ts
type C = new () => {
    [T in keyof Person]: Person[T]
}
```

这下，类里面也可以使用映射类型了，我们就能干更多的事了，当然我们需要借助一些函数来实现实例化：

```ts
function createC(c: C) {
    return new c();
} 
```

## 黑魔法

到此为止，恭喜你已经学会了ts的所有东西，那么，你可以用这些东西搞出来各种神秘的东西出来。现在我可以很认真地告诉你：ts的类型系统是图灵完备的，也就是说，它可以干任何计算机能干的事（当然绘制可能做不到，但是搞点象棋魔塔什么的还是可以的。那么就让我们把目前学到的所有东西结合起来吧！

### 函数转发

首先我们需要几个挂载到core上的实例，这里随便搞了点作为示例

```ts
class Control {
    constructor()

    debug(): void

    removeFlag(name: string): void
}

class Events {
    constructor()

    startGame(hard: string, seed: number, route: string, callback?: () => void): void

    gameOver(ending?: string, fromReplay?: boolean, norank?: boolean): void
}

class Actions {
    constructor()

    doAction(): void
}

class Core {
    events: Events
    control: Control

    constructor()
}
```

这样，我们成功地将两个实例挂载到了core上，下一步我们需要进行转发。

首先我们先思考一下转发的流程。第一步，获取要转发的实例中的所有键，并筛选出函数。第二步，将这些函数挂载到core上。经过“简单”的分析，我们可以得到以下代码：

```ts
type Forward<T> = {
    [K in keyof T as T[K] extends Function ? K : never]: T[K];
};

type Forwarded = Forward<Control> & Forward<Events> & Forward<Actions>;

type CoreInstance = Core & Forwarded;

function forward(core: Core, ...ins: (new () => any)[]): CoreInstance {
    const f: Partial<Forwarded> = {};
    for (const i of ins) {
        // forward
    }
    return Object.assign({}, core, f as Forwarded);
}

const core = forward(new Core(), Control);
```

### 四则运算

首先我们先来讲一下迭代。我们知道，在es6中，js出现了迭代器这个东西，这使得很多操作变得极为简单，例如扩散运算符：`[...arr]`，而ts的元组也可以这样，那么，这说明元组是可以叠加的，同时ts可以推断出元组的长度，从而让我们可以通过操作元组来实现四则运算（当然负数不行）。首先我们来看如何推断元组的长度：

```ts
type A = [1, 1, 1]['length']
```

那么，首先我们要根据一个数创建一个对应长度的元组的类型

```ts
type A<Length, Now extends number[]> = Now['length'] extends Length ? Now : A<Length, [1, ...Now]>;
type Arr<N extends number> = number extends N ? 1[] : A<N, []>;
```

对于生成数组，它一定是从0开始向上增加的，因此只要判断是否等于目标长度就行了。下面，我们就能用这些东西搞出来加法了

```ts
type Add<A extends number, B extends number> = [...Arr<A>, ...Arr<B>]['length']
```

很神奇吧（，下面来看减法，首先我们进行一下简单的数学运算：减法的运算为：差 = 被减数 - 减数，那么 被减数 = 减数 + 差，因此，我们可以使用infer推断出差值：

```ts
type Sub<A extends number, B extends number> = Arr<A> extends [...Arr<B>, ...infer R] ? R['length'] : never;
```

事情逐渐变得奇妙了起来，下面让我们来做乘法。乘法就是A个B相加，本质上还是加法，每加一次就让其中一个数减一，运用递归即可

```ts
type _Multi<A extends number, B extends number, Now extends unknown[]> = B extends 0 ? Now['length'] : _Multi<A, Sub<B, 1>, [...Now, ...Arr<A>]>
```

还有一个除法，转换为数组思路为长度为 m 的数组由多少个长度为 n 的数组组成

```ts
type _Divide<A extends number, B extends number, Now extends 1[][]> = A extends 0 ? Now['length'] : _Divide<Sub<A, B>, B, [Arr<B>, ...Now]>
type Divide<A extends number, B extends number> = _Divide<A, B, []>
```

那么，四则运算现在你已经学会了，那么下面让我们来做点尝试（，我们声明一个函数，它的功能是把10进制rgb转换为16进制，那么类型怎么写呢？

答案：

```ts
// 带余除法
type _DivideBy<A extends number, B extends number, Now extends unknown[]> =
    Sub<A, B> extends never
        ? [ Now["length"], A ]
        : _DivideBy<Sub<A, B>, B, [unknown, ...Now]>
type DividedBy<A extends number, B extends number> = _DivideBy<A, B, []>;

type HexCharacters = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'];
type HexCharacter<T extends number> = HexCharacters[T];

type TwoDigitHex<T extends [ number, number ]> = `${ HexCharacter<T[0]> }${ HexCharacter<T[1]>}`;
type NumberToHex<T extends number> = TwoDigitHex<DividedBy<T, 16>>;

declare function rgbToHex<R extends number, G extends number, B extends number>(r: R, g: G, b: B): `#${ NumberToHex<R> }${ NumberToHex<G> }${ NumberToHex<B> }`;
```