# 第四章 第一节 了解类型

## 什么是typescript

typescript（简称 ts） 是一种 javascript 的方言，所谓的方言，指的是与一门语言只有少数不同的变种，更进一步的，ts 被设计为 js 的超集，也就是说，任何一段合法的 js 代码同样也是合法的 ts。ts 在 js 的基础上增加了一套强大的类型系统，以及相关的语法。

如果你学过 C, java 等语言，你对类型系统应该不会陌生，类型系统的作用是约束变量的取值范围，避免一些代码上的错误，例如说以下 js 程序：

```js
let a = 1;
a.forEach((item) => console.log(item));
```

这段代码在语法上并没有错误，但是在运行时则会抛出错误，因为 `a` 是一个 `number` 类型的变量，它没有 `forEach` 方法，在 ts 出现以前，人们要在真正运行程序的时候才能发现这个错误，而在 ts 中，在编写程序时，语言服务会直接提示 `forEach` 是一个 `a` 中不存在的方法。这样，可以避免很多潜在的错误，程序调试所需要的时间就大为减少。

ts 也能提供自动补全上的方便，例如说当你打出 `a` 后面的 `.` ts 会提示你所有 `number` 类型变量所拥有的方法，不用凭借记忆拼写。

实际上，当你在使用 `codelab` 的代码编辑器时，你已经在使用 ts 了：现代 js 语言服务会使用 ts 语言服务来检查 js 代码的正确性，只不过它不会强硬的报错，只提供补全的建议。

官方文档（纯英文，可以训练英语）：https://www.typescriptlang.org/docs/handbook/intro.html

## 开始编写 typescript

VSCode 提供了开箱即用的 typescript 支持，打开 VSCode 并创建一个后缀名为 `.ts` 的文件就可以编写 typescript 了。

## 运行ts文件

ts无法直接在浏览器上运行，如果我们想要运行的话，需要先进行转译，将其变为 js。为此，我们需要安装相关的工具。

你可以运行 `npm i -g typescript` 全局安装 typescript 工具，之后使用命令`tsc 文件路径`即可将 ts 文件转换为 js 文件，然后就可以用浏览器或node运行了。当然，如果想要直接运行ts，可以使用deno，不过我们不讲这种方法，我们会在之后使用脚手架解决这个问题。

不过，一直使用tsc命令转译显得很麻烦，ts为我们提供了一种监听方案，使用`tsc watch 文件路径`，可以在每次保存后自动进行转译。

为了学习上的方便，我们提供了一个定制化的启动服务，你可以在学习群的群文件找到它，它的表现很像启动服务（因此你可以直接基于它进行样板开发），但是它能支持你直接引入`.ts`后缀的文件。

## 基础类型

在ts中，基础类型与js一样，包括 `string` `number` `boolean` `object` `function` `undefined` `bigint` `symbol` 共八种。在写ts时，我们可以明确指定某个变量的类型，语法是在原先的变量声明语句中加入 `: 变量名`，如下列代码

```ts
let x: number = 1;
const y: string = 'h5nb';
```

当然，我们大部分情况不需要特别指明变量的类型，因为ts可以进行类型推导，判断变量的类型，如果你使用 VSCode，可以将鼠标悬停在变量名上，会提示该变量的变量名。

```ts
let x = 12345; // 类型推导会得到x的类型为number
const y = 'lhjnb'; // y的类型为string
```

## 联合类型

ts 假设你的变量始终属于一个同样的类型，也就是说，以下代码会发生错误：

```ts
let x = 1;
x = 'h5nb';
```

因为 `number` 类型的数据无法转变成 `string` 类型，不过，如果你确实有需求让 `x` 这个变量能接受 `number` 和 `string` 两种功能， ts 提供了一个非常重要的能力来解决问题：`联合类型`(union type)。

### 声明联合类型

联合类型指的是 "取值范围是多个类型取值范围的并集" 的类型。在 ts 中你可以使用 `|` 连接多个类型，例如说下面的例子：

```ts
let x: string | number = 1;
x = 'h5nb';
```

这样 ts 就不会报错了，我们可以随意将 `x` 在数字和字符串之间相互转换。

## 类型断言

### 新的问题

接着上面的代码，如果我们这么写

```ts
let x: string | number = 1;
x = 'h5nb';
x.split('5');
```

这样就会报错，提示说 `number类型不存在split属性`，因为在这时候，x的类型是 `number | string`，但是 `number` 类型是没有 `split` 方法的，因此 `x.split` 这个调用是可能出错的，就会出现如上报错

### 进行类型断言

为了解决这个问题，ts使用了类型断言，即告诉ts`相信我，这个变量的类型就是这个`，从而让ts知道了更精确的类型，有两种写法

```ts
// 写法1，常用写法
x as string; // 注意as的优先级较高，必要时要加括号
// 写法2，不常用写法，在tsx中会报错，不推荐
<string>x;
```

不过，类型断言是有潜在的风险的，如果实际上变量的类型并不是被断言的那样，代码在运行中仍然会发生错误，因为断言只是修改了 ts 的判断，而不会对运行过程产生任何影响。

```ts
let x: string | number = 1;
(x as string).split('5'); // 在实际运行中仍然会报错
```

### 类型守卫

一种更安全的手段是使用类型守卫，类型守卫是 ts 附加在条件语句上的特殊能力，如果你在 `if` 语句的条件中使用 `typeof` `in` 等语句判断变量的类型，在 `if` 块和 `else` 块中，变量的类型会对应的收窄。这一技术被称为 `基于控制流分析的渐进定型`，是 ts 的核心概念。

```ts
(x: string | number) => {
    if (typeof x === 'number') {
        x.split('5'); // 此时 x 的类型是 number 因此会报错
    } else {
        x.split('5'); // 此时 x 的类型是 string，可以正常调用方法
    }
}
(x: Window | Document) => {
    if ("body" in x) {
        return x.createElement("div"); // 此时 x 的类型是 Document
    } else {
        return x.document.createElement("div"); // 此时 x 的类型是 Window
    }
}
```

相比于类型断言，类型守卫能保证实际运行的正确性，因此除非特别确信变量类型，否则都应该使用类型守卫。

特别的，除了使用内置的运算符，你也可以定义自己的类型守卫

## 字面量类型

### 新的问题

只用`string`或`number`类型时，会发现一个问题，那就是我们无法得知字符串和数字的准确内容，为此，ts为我们提供了字面量类型

### 声明字面量类型

声明字面量类型很简单，如下例

```ts
let x: 'lhj' | 'h5' = 'lhj';
let y: 1 | 2 | 5 = 2;
```

声明方式类似于联合类型，属于可辨识联合的一部分。这样，在之后的代码中，ts就知道了这个变量的准确字面量，从而让类型更为精确

## 类型别名

### 又有新问题

如果我们声明了一个很长的类型，同时又需要频繁使用，那么就会显得很啰嗦，可读性也差，为此，ts为我们提供了类型别名这个东西

### 使用类型别名

类型别名是一个形如 `type 别名 = 类型` 的语句：

```ts
type MyType = 'lhjnb' | 'h5nb' | '鹿神nb' | '艾神nb';
let x: MyType = 'lhjnb';
```

由此可见，`MyType`类似于一个变量，但在代码中并不会执行，只是用作一个类型声明。当然，我们还可以这样使用类型别名

```ts
type MyType1 = 'h5nb';
type MyType2 = 'lhjnb';
type MyType = MyType1 | MyType2;
```

这种方式也是合法的
