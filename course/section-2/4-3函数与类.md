# 第三节 函数与类

## 函数

### 基础语法

在第一节中我们已经介绍过函数的类型声明语法，因此这里只进行展示：

```ts
function fn(a: number, b?: string, c = false): void {

}
const fn2 = (...rest: number[]): number => {
    return rest[0];
}
```

比较有趣的是，直接对 fn2 标注类型也能达到类似的效果：

```ts
const fn2: (...rest: number[]) => number = (...rest) => {
    return rest[0];
}
```

利用这个特效，你可以将多个 lambda 标注为同一个类型。

### never

### 重载

利用联合参数和可选参数，可以有效的约束函数的参数，但是某些时候我们希望更进一步的约束，考虑以下函数：

```ts
function cast(a: string, to: "number" | "boolean") {
    if (to === "number") return Number(a);
    else return Boolean(a);
}

const res = fn("1", "number"); // number | boolean
```

显然，如果 `to` 是 `"number"` 得到的结果总是 `"boolean"`，针对这种情况，ts 提供了重载函数的能力，具体来说，这个能力可以将函数的类型约束为几个可能性之一，像这样：

```ts
function cast(a: string, to: "number"): number
function cast(a: string, to: "boolean"): boolean
// 上面两个为重载的函数签名
function cast(a: string, to: "number" | "boolean") {
    if (to === "number") return Number(a);
    else return Boolean(a);
}

const res = fn("1", "number"); // number
```

当函数设置了重载签名时，传入的参数必须符合其中某个重载签名才能被接受，同时返回值也会被收窄到该签名对应的返回值，另外一方面，重载也会约束函数本身，例如说以下代码：

```ts
function cast(a: string, to: "number"): number
function cast(a: string, to: "boolean"): boolean
function cast(a: string, to: "number" | "boolean") {
    return Boolean(a);
}
```

注意到 `cast` 函数本身的签名会被推导为 `(a: string, to: "number" | "boolean") => boolean`，第一个重载无法满足，因此会报错。

### 逆变与协变

对于之前的所有类型，我们都能很直观的理解进行赋值时的约束：

## 类

### 访问控制符

也许你已经使用过 js 中的类，或者有其他OOP语言的使用经验，但是如你所见，js 中没有访问控制符

### 抽象类

### this
