# 第三节 函数与类

## 函数

### 基础语法

在第一节中我们已经介绍过函数的类型声明语法，因此这里只进行展示：

```ts
function fn(a: number, b?: string, c = false): void {

}
const fn2 = (...rest: number[]): number => {
    return rest[0];
}
```

比较有趣的是，直接对 fn2 标注类型也能达到类似的效果：

```ts
const fn2: (...rest: number[]) => number = (...rest) => {
    return rest[0];
}
```

利用这个特效，你可以将多个 lambda 标注为同一个类型。

### 重载

利用联合参数和可选参数，可以有效的约束函数的参数，但是某些时候我们希望更进一步的约束，考虑以下函数：

```ts
function cast(a: string, to: "number" | "boolean") {
    if (to === "number") return Number(a);
    else return Boolean(a);
}

const res = fn("1", "number"); // number | boolean
```

显然，如果 `to` 是 `"number"` 得到的结果总是 `"boolean"`，针对这种情况，ts 提供了重载函数的能力，具体来说，这个能力可以将函数的类型约束为几个可能性之一，像这样：

```ts
function cast(a: string, to: "number"): number
function cast(a: string, to: "boolean"): boolean
// 上面两个为重载的函数签名，下面的是实现，其类型必须满足上面两者
function cast(a: string, to: "number" | "boolean") {
    if (to === "number") return Number(a);
    else return Boolean(a);
}

const res = fn("1", "number"); // number
```

当函数设置了重载签名时，传入的参数必须符合其中某个重载签名才能被接受，同时返回值也会被收窄到该签名对应的返回值，另外一方面，重载也会约束函数本身，例如说以下代码：

```ts
function cast(a: string, to: "number"): number
function cast(a: string, to: "boolean"): boolean
function cast(a: string, to: "number" | "boolean") {
    return Boolean(a);
}
```

注意到 `cast` 函数本身的签名会被推导为 `(a: string, to: "number" | "boolean") => boolean`，第一个重载无法满足，因此会报错。

### void

`void`是ts中的一个特殊类型，它表示空值，`undefined`和`null`可以分配给它。一般地，当函数没有返回值时，它的返回值就是`void`：

```ts
function test(): void {
    console.log('test');
}
```

当然，如果出现了`return`关键字但没有返回值时，其返回值也是void：

```ts
function test2(): void {
    return;
}
```

或者返回了`undefined`或`null`：

```ts
function test3(): void {
    return void 0;
}
```

或者调用了一个函数，这个函数的返回值是`void`，然后并将其返回：

```ts
function test4(): void {
    return test2();
}
```

一般情况下，`void`只会出现在函数的返回值中，其余地方是不规范的

### never

`never`是ts中的一个特殊的类型，它表示不可能出现的值，任何值都不能分配给它。一般情况下，当一个函数不可能会运行完成时，它的返回值就是`never`，或者当类型推断出不可能出现时也是`never`。首先看函数不可能运行完成：

```ts
function fail(msg: string): never {
    throw new Error(msg);
}
```

这时，当函数运行到`throw`时，这个调用链就会直接断开，不再进行任何操作，那么也就是说`fail`这个函数根本就没运行完就被掐掉了，这时它的返回值就是`never`

然后就是类型推断出不可能出现了，它一般会在条件语句中出现。

```ts
function test(a: number | string): void {
    if (typeof a === 'number') {
        console.log('a是数字');
    } else if (typeof a === 'string') {
        console.log('a是字符串');
    } else {
        console.log('a是never'); // a是数字或字符串，而这里把这两个都排除了，因此是never
    }
}
```

特别地，当没有标注时，空数组`[]`的类型为`never[]`，空对象`{}`的类型为`{ [x: string | number | symbol]: never }`

## 类

类的类型标注很简洁：

```ts
class People {
    age: number
    sex: 'male' | 'female'
    work?: string

    constructor(age: number, sex: 'male' | 'female') {
        this.age = age;
        this.sex = sex;
    }

    setWork(work: string): void {
        this.work = work;
    }
}
```

这样，这个类就包含了基本所有的元素。`constructor`是在构造是调用的函数，即这个类被`new`时调用的。`setWork`是类上的一个函数。类本身也是一种类型，意味着任何属性和变量常量的类型都可以是一个类，表示这个属性或变量或常量是这个类的实例：

```ts
class Group {
    member: People[]

    constructor() {}
}
```

### this

类中的`this`可以用来调用类的属性，例如：

```ts
class People {
    age: number
    sex: 'male' | 'female'

    constructor(age: number, sex: 'male' | 'female') {
        this.age = age; // 使用this调用age属性
        this.sex = sex;
    }
}
```

### 类的继承

不同类间可以继承，但注意这里继承不像接口可以继承多个，类能且只能继承一个类，如果想要同时继承两个类是做不到的。类的继承使用`extends`运算符，当一个类继承完毕后，必须调用它父类的构造函数，使用`super(...params)`

```ts
class Animal {
    species: string

    constructor(species: string) {
        this.species = species;
    }

    eat() {
        
    }
}

class People extends Animal {
    constructor() {
        super('human'); // 调用父类的构造函数，传入'human'作为其构造函数的参数
        this.species; // 这里就能直接用this调用了
    }

    eat() {
        // 可以直接重新实现父类的函数
        // 如果需要调用父类的函数，需要用super.xxx()
        super.eat();
    }
}
```

### 访问修饰符

也许你已经使用过 js 中的类，或者有其他OOP语言的使用经验，但是如你所见，js中没有访问修饰符（新的es标准还真有，有#表示私有属性，static表示静态属性），但是ts中是有的。

#### public

公有属性，当没有修饰符时就是`public`，也就是说`public`是不需要特别指明的

```ts
class People {
    public age: number = 18 // public加不加效果相同
}
```

#### readonly

意思是`read-only`，不是`readon ly`，意为只读属性，只能在创建类或者在`constructor`中赋值，否则ts会报错。例如：

```ts
class People {
    readonly age: number = 18 // 创建类的时候初始化赋值

    constructor(age?: number) {
        if (age !== void 0 && age !== null) {
            this.age = age; // 构造函数里面允许赋值
        }
    }

    setAge(age: number) {
        this.age = age; // 报错，因为age是只读属性，这里不能给它赋值
    }
}
```

#### static

静态属性，不会因为类被实例化而改变，是类的属性，而不是实例的属性。例如：

```ts
class Group {
    static cnt: number = 0
    readonly member: People[] = []

    constructor() {}

    add(people: People) {
        Group.cnt++; // 调用静态属性需要用 类名.xxx，如果使用this.cnt是调用不到的，并且会报错
        this.member.push(people);
    }
}
```

#### private

`private`表示这个属性是私有属性，外部和子类中均不能访问，例如：

```ts
class People {
    private sex: 'male' | 'female'

    constructor(sex: 'male' | 'female') {
        this.sex = sex; // 允许访问，因为在类的内部
    }

    setSex(sex: 'male' | 'female') {
        this.sex = sex; // 这里也能访问，因为也在类的内部
    }
}

const p = new People('male');
p.sex; // 报错，类的外部不能访问私有属性
```

#### protected

`protected`表示这个属性只能在类或其子类中访问，例如：

```ts
class Animal {
    protected species: string

    constructor(species: string) {
        this.species = species; // 允许访问，因为在类内部
    }
}

class People extends Animal {
    constructor() {
        super('human');
        this.species; // 允许访问，因为在其子类中
    }
}

const animal = new Animal('monkey');
animal.species; // 不允许访问，因为在类的外部
const people = new People();
people.species; // 不允许访问，因为在类的外部
```

#### 组合

这些修饰符是可以组合的，例如你可以创建一个这样的属性：

```ts
class Group {
    protected static readonly cnt: number
}
```

其中`protected`和`private`不能共存，顺序应是`public | protected | private` `static` `readonly`

函数也同样适用上述所有内容

#### 非空断言 可选属性 索引属性

类本质上还是个对象，所以对象能用的类一般也能用

```ts
class People {
    age!: number // 非空断言
    work?: string // 可选属性
    [x: number]: any // 索引属性
}
```

### 抽象类

抽象类是一种特殊的类，它不能直接被实例化，一般作为基类使用。其中的抽象函数由其子类实现，其自身也可以实现非抽象函数

```ts
abstract class Animal { // 定义抽象类用abstract
    age: number

    abstract eat(): void // 抽象函数，子类中必须有实现，否则报错

    drink(): void {
        // 非抽象函数，可以直接实现
    }

    // 抽象类中可以有constructor，也可以没有
}

const animal = new Animal(); // 报错，抽象类不能被实例化
```

继承：

```ts
class Human extends Animal {

    constructor() {
        this.age = 18; // 可以直接使用抽象函数的属性
    }

    eat() {
        // 子类中必须有抽象函数的实现
    }
}
```

## 逆变与协变

对于之前的所有类型，我们都能很直观的理解进行赋值时的约束：

```ts
class Animal {

}

class People extends Animal {

}
let dog = new Animal(); // dog的类型是Animal
let people = new People(); // people的类型是People
let animal: Animal = people; // 但是如果这样会发生什么？
```

那么我们如何理解第三个赋值呢？这里便联系到了逆变与协变。逆变与协变可以让类型系统更加安全。生活中有一个很常见的例子：国 > 省 > 市 > 县，这里便涉及到了逆变与协变。一般来讲，当类型收窄时，我们称之为协变，当类型扩大时，我们称之为逆变，它遵循LSP（里氏替换原理，不是那个lsp）。很显然，在上述例子中，`People => Animal`的转换会让类型扩大，而`Animal => People`的转换会让类型收窄。在第三个赋值中，我们定义变量的类型是`Animal`，但我们传入了`People`，这时，就会发生协变`Animal => People`。很显然，这个转换是合法的，因为`People`是`Animal`的子类，它必然包括`Animal`的所有属性。

对于逆变，它一般发生在函数中：

```ts
function a(animal: Animal): void
function a(animal: People): void {

}
```

这里，我们定义函数的参数类型为`Animal`，但我们在实现时却定义它为`People`，这里就会发生逆变`People => Animal`，类型发生了扩大。很显然，`People`是满足`Animal`的，所以这里不会报错。

对于函数的返回值，它也允许发生协变：

```ts
function a(): People 
function a(): Animal {
    return new Animal();
}
```

显然，这里会发生`Animal => People`的协变，这是合法的，因此不会报错。