# 模块化

在es6以前，js的规范里是没有`模块化`这个概念的，非常笨重。

es6提供了模块化的规范。

es6将每一个文件看作一个模块，各个模块不会影响到其他的模块。

模块默认启用严格模式，即`'use strict'`



es6规范要求模块必须有显式的导出声明，使用`export`关键字。

导出分两种，一是普通导出，二是默认导出,

导入与导出一样，分普通导入和默认导入。

## 导出

### 普通导出

直接在想要导出的变量前加入`export`关键字即可。

```js
// 文件名：a.js
export let a = 2
export let b = function(){
    
}
export class C {
    
}
export function d(){
    
}
```

需要注意的是，这样的导出是不可以的：

```js
export 2 // 错误
let a = 2
export a // 错误
// 但我们可以改写成这样
let a = 2
export { a } // 这样是可以的
```

其次，`export`关键字必须放在一个模块的顶层！

比如，这样的也是不可以的：

```js
let a = 2
if(xx){
	export a
    // export必须处于当前模块的顶层！
}
```

导出来的变量拥有自己的名字，方便我们导入时直接用变量名取。

很像解构赋值。

我们也可以为导出的变量取个别名：

```js
let a = 2
export {
	a as A
}
// 以后在外部导入时就可以用'A'来取了。
```



### 默认导出

不同于普通导出必须有变量名，默认导出是直接导出一个值！

只需再加入一个关键字`default`:

```js
export default 2
export default {
    a:1
}
let a = 2
export default a
```

当然，也正因为默认导出没有名字，所以导入时的写法也不同。

**实质上，默认导出相当于把值赋给了`default`这个变量**

需要注意的是，普通导出可以出现多次，但默认导出在一个模块内部只允许出现一次！

## 导入

导入语法使用`import`关键字，示例：

```js
// a.js
export let a = 2
// b.js
import {a} from 'a.js' // 这里的{a}可以看作解构赋值,但它并不是解构赋值！只是方便理解
a // 2
```

注意,`from`关键词后跟着的是要导入的路径。

有时导入变量名会和我们自己写的变量名产生冲突，这时我们可以为它取个别名：

```js
import {a as A} from 'a.js'
```

然鹅，默认导出是没有名称的，我们需要这样做：

```js
// a.js
export default 2
// b.js
import _ from 'a.js'
_ // 2
// 还记得上文提到的吗？默认导出可以看作是导出了一个名为defualt的变量
// 因此，我们还可以这样：
import {default as _} from 'a.js'
// default是关键字，所以取个别名
_ // 2
```

默认导出没有名字，所以我们可以为它取任何名称。

当然，这两者也可以同时导入：

```js
// a.js
export let a = 2
export default 2
// b.js
import _,{a} from 'a.js'
_ // 2
a // 2
```

### 全部导入

最后，假如一个模块有几千个导出，我们想全部引入，不可能去一个一个手写，所以es6提供了这样的一个方法：

```js
// a.js
export let a = 2
// 很多很多导出
export default 2
// b.js
import * as A from 'a.js'
// 如此一来，所有的导出(包括默认导出)都成为了A这个对象的属性
A.a // 2
A.default // 2
```

## 模块的转发

某些时候，我们是不需要直接使用某个模块的导出的，我们只是想做一个中转站：

a.js=>c.js 比如，文件c要引入文件a里面的部分内容，我们想做个包装：

a.js=>b.js(引入a的一部分，再直接导出来)=>c.js

这种行为实质上就是`转发`：

```js
// a.js，一个非常大的外部模块
// 。。。
export let a = 2
// b.js 这是一个我们项目内部的文件
import {a} from 'a.js'
export {a}
// c.js 现在我们可以直接从项目内的b文件拿到想要的东西了
import {a} from 'b.js'
a // 2
```

像上面的b.js的转发操作可以写成一句：

```js
export {a} from 'a.js'
```

简洁明了。

**全部转发**可以也写成这样：

```js
export * as A from 'a.js'
```

## 动态导入

上文我们提过，导出只能放在模块顶部。

导入也是一样的，但`动态导入`允许我们在任何地方使用。

思考这样一个场景：一个网站的某个页面很少有人会去访问(但这个页面仍然重要！)，这里我们大致的将每个页面看作模块。

这意味着：某个模块很少会用到，但我们依然会在每个人访问网站时都加载一遍！

为了解决这种问题，`动态导入`出现了。

它允许我们去判断一个模块是否应该被导入，语法如下：

```js
// 满足某个条件时
if(xxx){
    // 动态导入a.js文件
    import('a.js')
}
```

**注意！import()和super()长得虽然很像函数调用，但它们并不是函数！它们只是语法**

`import(module)`返回一个promise,内部包裹的值就是这个模块的所有导出。

```js
// a.js
export let a = 2
export default 3
// b.js
if(xxx){
    import('a.js').then({default as _, a}=>{
        _ // 3
        a // 2
    })
}
```

当然，promise就可以用async函数来更方便的处理：

```js
// a.js
export let a = 2
export default 3
// b.js
async function imp(){
	const {default as _,a} = await import('a.js')
    _ // 3
    a // 2
}
if(xxx){
 imp()   
}
```

除此之外，`import()`还允许动态的参数。