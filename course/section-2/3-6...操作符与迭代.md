# 解构赋值，操作符与迭代

## 1. 解构赋值

假如有一个数据`point` = {x:1,y:1,z:1}，在es6以前我们为了取出这个对象的各种属性，我们需要

```js
let x = point.x
let y = point.y
let z = point.z
// 一旦数据的属性多了起来非常不方便！
```

es6允许我们用一种非常简便的方式来取得数据，称为’解构‘，示例：

```js
let {x,y,z} = point
// 这个写法与上面的写法等价！
// 但是变量名必须要与对象的方法名一致
let {l} = point
l // undefined 
// 不匹配的值会是undefined
```

当然，我们也可以只取想要的数据，不必全部取出

```js
let {x} = point // x=1
// 也不需要一定按照顺序取
let {z,x,y} = point // 和xyz写法等价
```

数组同样可以解构，但有一些限制

```js
let [x,y,z] = [1,2,3] // 注意这里的变量用'[]'包裹而非'{}'
// 不同于对象解构，变量可以随便更换位置，数组的解构严格按照数组元素顺序解构
let [x, ,z] = [1,2,3] // x=1,z=3
let [ , ,z] = [1,2,3] // z=3
```

然鹅，对象解构必须使用方法名解构出来，这并不够灵活，而且有时对象的方法名是关键字！考虑如下代码：

```js
let {if} = {if:1}
// 结果是报错 Uncaught SyntaxError: Unexpected token 'if'
// 我们需要给if取个别名
let {if:myIf} = {if:1}
myIf // 1
```

解构同样可以嵌套

```js
let {a:[x,y,z],b} = {a:[1,2,3],b:2} // 这里解构出来的a是数组因此能再次解构，但a不会有值
// x=1,y=2,z=3,b=2
// a Uncaught ReferenceError: a is not defined
```

别忘了数组也是对象！因此我们可以写出如下代码（虽然没人会这么做但还是讲一下吧）

```js
let {0:x,length} = [1,2,3] 
// [1,2,3]可以大致看成{0:1,1:2,2:3,length:3}这样的对象，但数字不能作为一个变量名，所以我们给一个别名
x // 1
length // 3
```



还有几种解构方式，我们在下文介绍。

## 2. ...操作符

该操作符是es6新增的一种操作符，用处非常大，有多种使用场景而且代表着不同的意义

### 2.1 函数里的用法

```js
s(1,2,3)
function s(a,...b) {
    a; //1
    b; //[2,3]
}
```

这里的`b`称为rest参数，它起收集作用，将第一个参数以后的参数全部收集起来。

因此，b是一个数组，也给予了函数收集无限参数的能力。

不过，rest参数有一个限制，只能放在参数的末尾。

```js
function s(...a,b){} 
// 这是不允许的！！！
// Rest element must be last element
```

### 2.2 解构赋值的用法

它也可以用作解构赋值。

试想一下这样的情况：我需要取出`{x:1,y:2,z:3}`的x,y并将它们合并，而不是单独的解构x和y。

```js
let {z,...xAndy} = {x:1,y:2,z:3}
// xAndy将会把除了z以外的属性全部收集起来
xAndy // {x:1,y:2}
```

既然对象解构能用，数组解构自然也能用：

```js
let [x,...yAndz] = [1,2,3]
yAndz // [2,3]
```

仍要注意数组解构是严格按照顺序的！！！

当然，这种用于`收集`的写法，依然只能放在末尾

### 2.3 展开的用法

既然有收集(rest)的用法，自然也有展开(spread)的用法，具体如下：

```js
let newArray = [ ...[1,2,3] ]
newArray // [1,2,3]
```

它允许我们将一份数据拆开。

与解构类似，它也有对象，数组两种不同的用法。

思考一个问题，对象a和对象b如何快速合并？

一个比较简洁的做法是调一个Object身上的方法

```js
let newObj = Object.assign(obj1,obj2) // assign用于快速合并任意个
```

但这相比下面的写法仍然不够优雅：

```js
let newObj = {
    ...obj1,
    ...obj2
}
```

我们还可以轻易改变对象的某个属性

```js
let point = {x:1,y:2}
let newObj = {
    ...point,
    x:4
}
newObj // {x:4,y:2}
// 后面的值会把已有的值覆盖掉
```



`Object.assign({},obj) 几乎等价于 {...obj}`

es6以前，求数组内所有元素的最大值是用了种非常巧妙的方法：

```js
let getArrayMax = Math.max.apply(null,array)
// apply函数接受两个参数，一是绑定this到第一个参数，二则是将第二个数组一个一个拆开放入函数，作为原函数的参数
// 这不正是展开操作符的作用么？！
// 因此，在es6以后，我们可以直接写
let getArrayMax = Math.max(...array)
```

## 3. `??`与`?.`与默认参数

在以前，我们为了对函数的参数做出限制总是要写一些多余的判断：

```js
function add(a,b){
	return a+b
}
```

别人调用此函数时完全可能少几个参数，甚至一个参数都不填，为了代码健壮性我们不得不写出这样的代码：

```js
function add(a,b){
    a = a || 0
    b = b || 0
	return a+b
}
```

现在，我们可以在函数定义时显式指出`默认参数`！

```js
function add(a=0,b=0){
	return a+b
}
// 在参数值为null 或 undefined时(为空)，默认参数便会当作参数。
add() === 0 // true
```

甚至，我们可以在解构赋值中也使用`默认参数`！

```js
function add({x=0,y=0}={}){
    return x+y
}
// 这里实际上是add(obj={}),再对obj解构
// 因为obj如果为空是会报错的(Cannot read properties of undefined)，因为空值无法解构，所以需要对obj也做处理

// 函数可以变量自然也可以!
let {a,b=3} = {a:2}
a // 2
b // 3
```

再来谈回`||`这个常用的逻辑操作符，因为某些原因，`0`,`''(空字符串)`,`false`都会导致逻辑值为`false`从而违背我们的预期，因为有时我们只是想判断空值`null`,`undefined`而已。

于是js有了`??`操作符，用于判断一个值是否为空：

```js
0??2 // 0
''??2 // ''
false??2 // false
0||2 // 2
''||2 // 2
false||2 // 2
```

事实上，上文提到的默认参数都是对数据做了`??`操作而非`||`。

#### `?.`可选链操作符

在以前，我们读取一个有可能为空的数据是非常非常麻烦的。

```js
let data = {
    a:{
        b:{
            c:{
                d:{
                    e:{
                        //....
                        z:{
                            x:0
                        }
                    }
                }
            }
        }
    }
}
// 现有一个这样的数据，它很不稳定但我们需要将它的a.b.c.d.e.z.x进行加一
// 以前的写法是一级一级的判断是否为空，非常非常麻烦。
```

有了`?.`操作符后，我们可以这样：

```js
let result = (a?.b?.c?.d?.e?.z?.x) ?? 'default';
```

只要有任意一个属性值为空，逻辑立刻中断并且不会再报`Cannot read properties of undefined`这样的错误。

## 4. 迭代与生成器与async，await

经过上面三部分的解说，想必各位都已经对几个新操作符以及结构赋值这几个概念有了大致的了解，在js的实际开发中，它们也是非常常用的技巧。

## 4.1 可迭代对象

还记得for循环吗？除开最常见的`for(let i = 0;i<10;i++){}`这种循环之外，还有两种特殊的循环。

它们是`for in`以及`for of`。

粗略的说，`for in`遍历键，`for of`遍历值，比如：

```js
let obj = {a:1,b:2}
for(let key in obj){
    key // 'a' , 'b'
}
```

但是有个很大的问题，一般来说，我们遍历数据时都是更希望直接拿到值，为什么对象不能直接用`for of`?而是要`obj[key]`这种形式拿值？

不用思考的敲下如下代码：

```js
let obj = {a:1,b:2}
for(let value of obj){
	value
}
```

报了一个奇怪的错误`obj is not iterable`，直译过来就是，obj是不可迭代的。

凭啥你数组能迭代,我对象不行？于是，你打开控制台输入一个空数组，开始找它族谱(原型链)；

没找几层，我们马上看到了一个奇怪的属性**Symbol.iterator**。

是的，官方规定，一个可迭代对象身上必须实现了[Symbol.iterator]方法，且这个方法需要返回一个具有next方法的对象。

即`[Symbol.iterator]=>{next}`

原来如此！一旦有了这个属性我们就能让一个数据变成可迭代的：

```js
let obj = {a:1,b:2}
obj[Symbol.iterator] = function(){
    let _count = -1
    let _keys = Object.keys(this)
    let _length = _keys.length
    return {
        next:()=>{
            _count++
            return {
                value: _count===_length ? null : this[_keys[_count]],
                done: _count===_length ? true : false
            }
            // 规定，[Symbol.iterator]方法必须返回一个具有next方法的对象。
            // 并且，next方法必须返回一个具有value，done属性的对象。
            // 该对象的value属性作为每次迭代的结果。
            // 该对象的done属性用于指示迭代是否应该结束。(一直是false的话浏览器会死循环)
        }
    }
}
for(let v of obj){
    v // 1,2
}
```

本质上，一个数据被迭代时，就是在调用它身上的`Symbol.iterator`方法，同时不停的调用`next`方法；

感觉好像有什么东西和`for of`很像啊，也是在迭代数据。

不错，正是`...`操作符，当它`用于在数组内展开数据时`，它也是在迭代！！

(上文已经说过，对象内使用展开操作符时，只是相当于Object.assign方法而已)

故有如下代码：

```js
let test = [...obj] // obj在上文已经实现了迭代方法
test // [1,2]
```

目前，常用的，自带迭代器的数据结构有：

- String 字符串本质上是特殊的数组
- Array
- Map,Set (es6新增)

正因如此，它们都是可以使用`...`以及`for of`的。

## 4.2 生成器函数(Generator)

我们可以显式的在函数声明时添加`*`符号，说明该函数是生成器函数。

`function* (){ //... }`

这个函数的作用在于，它提供了轻松分割代码执行的能力。

在该函数内，可以使用独有的关键词：`yield`(就如同`async`函数内部独有的`await`);

```js
function* a(){
    console.log(1)
    yield 1
    console.log(2)
    yield 2
    console.log(3)
    yield 3
}
let generator = a(); 
// 该函数会得到一个拥有next方法的对象。
generator.next() // 输出1，返回值是{value:1,done:false}
generator.next() // 输出2，返回值是{value:2,done:false}
generator.next() // 输出3，返回值是{value:3,done:false}
generator.next() // 返回值是{value:undefined,done:true}
```

可以明显看出，代码被轻松的分割执行了。

上一小节认真的话，相信你马上就能看出来这熟悉的`next`，熟悉的`value`和`done`，不正是迭代方法返回的对象吗！？

因此，上一小节显得很臃肿的obj迭代方法可以改写为：

```js
let obj = {a:1,b:2}
obj[Symbol.iterator] = function* (){
    let _count = 0
    let _keys = Object.keys(this)
    let _length = _keys.length
    while(_count<_length){
        _count = (yield this[_keys[_count]]) ?? _count+1
    }
}
for(let v of obj){
    v // 1,2
}
```

`yield`表达式不只能用来卡住程序执行，`next`方法被调用时还可以往里传参。

这个参数会成为yield表达式的值！！！

在上文中，`for of`以及`...`是不会给next方法传参数的，因此有`_count = undefined ?? _count+1`相当于它自增；

因此，当`_count`大于等于`_length`时，循环停止，此时已经没有yield表达式了，函数执行完毕，自动返回最后一对`{value:undefined,done:true}`。

这就是生成器函数强大的地方：不仅可以分段函数执行，还可以在过程中传入参数控制函数走向！

当然，生成器函数内部我们依然可以使用`return`,它依然会直接停止该函数并将它后面的值返回

最后得到的结果是`{value:返回值,done:true}`

## 4.3 最后，async与await

好了，终于到最后环节了。

通过解构赋值引出`...`操作符，再引出`迭代`这一概念，于是有了生成器函数，现在终于到了检验成果的时候了。

`async`，`await`这一对实际上是源于生成器函数的语法糖。

```js
// async与await
const promise = new Promise((resolve,reject)=>{
    reject(100)
})
const gFn = function* (){
    const myAwait = yield promise // 这里的yield实际上等价于await
    console.log(myAwait) // 应该为100
}
function myAsync(gFn) {
    return new Promise((resolve,reject)=>{
        const generator = gFn()
        const next = (Fn)=>{
            let nextResult = Fn() // value : Promise
            let {value,done} = nextResult
    		if(done){
                // done为true说明迭代完毕，终止promise
                // 此时value相当于gFn的返回值
                // 因为被resolve出去了，所以这就是async函数的返回值会被promise包裹起来的原因。
         		return resolve(value)
	    	}else {
                // Promise.resolve返回一个已经resolve的promise实例
                // 如果value是一个promise实例，该方法会将promise内部的值解出来
                // 因此有promise(v) === value
    			Promise.resolve(value).then(
                    v => {
        	            // 解出v值后再次调用next，此时yield表达式的值正是promise内部封装的值！
    	                // const v = yield Promise(100) // 伪代码。
	                    // v === 100
        				next(() => generator.next(v))
	    			}
                )
    		}
        }
        //初始化，第一次yield表达式并未执行，它在等待下一次next
        next(()=>generator.next())
    })
}
```

