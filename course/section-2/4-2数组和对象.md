# 第二节 对象与数组

## 对象

### 基础语法

与上节课中介绍的基础类型不同，对象类型非常丰富多彩，远非一个 `object` 可概括，实际上，`object` 的作用类似于 `unknown`，它仅能约束变量为 `object` 类型，但是不能标识变量拥有的成员：

```ts
let obj: object = { a: 5 };
obj.a; // 属性 'a' 不存在于 'object' 类型
```

如果想要标识对象所拥有的成员，要使用类似对象字面量的语法来描述：

```ts
let obj: { a: number } = { a: 5 };
```

特别的，分割多个属性时，可以用 `,` 也可以用 `;`，像这样：

```ts
let obj: {
    a: number;
    b: string,
    k: {
        r: string
    }
}
```

对于函数类型的成员，可以这样简写：

```ts
let obj: {
    numberToString(b: number): string;
}
```

当然，ts 会自动帮你进行推导：

```ts
let obj = { a: 5 } // { a: number }
```

### 可选属性

特别的，如果某些属性是可选的，我们可以使用 `?:` 来标识属性：

```ts
let obj: { a: number, b?: string } = { a: 5 };
```

在这种情况下，`b` 的类型会是 `string | undefined`，不过注意，这和直接声明 `b` 的类型为 `string | undefined` 的表现并不相同：

```ts
let obj: { a: number, b: string | undefined } = { a: 5 }; // { a: 5 } 中缺少了 b: string | undefined 属性 
```

你也可以用这个语法实现可选参数，不过，可选参数必须放在必选参数的后面，注意默认参数也是一种可选参数：

```ts
const fn = (a: number, b = '5', c?: boolean) => void 0; // 正确
const fn2 = (a: number, b?: boolean, c = '5') => void 0; // 正确
const fn3 = (a?: boolean, b: number, c = '5') => void 0; // 错误
```

### 非空断言

和 js 一样，你可以使用 `obj.prop ?? defaultValue` 来处理可能为空的属性，用 `obj?.prop` 来访问可能为空的对象的属性，不过，ts 还提供了另外一种手段 `非空断言`，非空断言的对应语法是 `obj.prop!` 和 `obj!.prop`，这两者类似于 `类型守卫` 和 `类型断言` 的区别，以下是一组示例：

```ts
const fn = (a?: { b: number }) => {
    a?.b; // 总是对的
    a!.b; // 如果传入的参数不如所愿，会报错
}
fn();
const fn2 = (a: { b?: number }) => {
    a.b ?? 1; // 总是有值
    a.b!; // 如果传入的参数不如所愿，仍然会是空值
}
fn2({});
```

### 只读属性

ts 还提供了更强的约束，你可以指定一个属性是只读的，在这种情况下，你将只能在初始化时进行一次赋值：

```ts
let b: { readonly r: string; } = { r: '1' };
b.r = '5'; // 不能赋值给 'r' ，因为它是一个只读属性
```

### 交叉类型

ts 允许我们创建交叉类型，交叉可以在任意类型之间进行，这会约束类型为拥有两个类型的方法的并集（恰好与联合的情况相反），例如这样：

```ts
let b: { a: string } & { b: string } = { a: '5', b: '6' };
```

你甚至可以将自定义对象与原始类型进行交叉：

```ts
type __String = string & { __prop: string };
const fn = (i: __String) => {
    console.log(i.__prop);
}
```

### 接口

对于对象类型，除了 `type` 之外，ts 还提供了 `interface` 关键字用于定义，它的用法与 type 大体类似：

```ts
interface SomeObject {
    a: string;
}
let obj: SomeObject = { a: '5' }; // SomeObject
```

不过，`interface` 的功能并不止于此，`interface` 可以继承其他的 `interface` 或者 `type`：

```ts
interface SomeObject {
    a: string;
}

interface SomeObject2 extends SomeObject {
    b: number;
}
let obj2: SomeObject2 = { a: '5', b: 1 }; // SomeObject2

type A = { k: boolean };

interface SomeObject3 extends A {
    c: SomeObject;
}
let obj3: SomeObject3 = { c: { a: 'x' }, k: false }; // SomeObject3
```

更进一步的，`interface` 还可以进行多继承：

```ts
interface SomeObject4 extends SomeObject2, SomeObject3 {

}
let obj4: SomeObject4 = { a: '5', b: 1, c: { a: 'x' }, k: false }; // SomeObject4
```

像 `java` 和其他一些编程语言一样，接口可以用来约束 `class`：

```ts
interface Countable {
    count(): number;
}

class Result implements Countable {
    count(): number {
        return 1;
    }
}
```

如果 `Result` 不能提供接口所描述的成员和方法，则会报错。

### 引用自身

如果你在写 `树` 或者 `链表` 一类的数据结构，你可能需要定义对象的一个成员为对象自己，这在 `ts` 中是合法的，不过你得借助 `type` 或者 `interface`：

```ts
type BiList = {
    next: BiList | null;
    prev: BiList | null;
}
```

### 索引

在对象一节中，我们提过，对象也可以作为字典，存储一系列类似的值，针对这种情况，ts 提供了索引语法，形如 `[ key: type ]: prop`：

```ts
interface UserInfo {
    id: string;
    name: string;
}

interface UserTable {
    [ k: number ]: UserInfo;
}

const userTable = {
    1188: {
        id: 1188,
        name: '老黄鸡',
    }
};
```

特别的，作为索引的类型只能是 `number`，`string`，`symbol` 或它们的联合类型。

## 数组

### 基础语法

ts 为数组类型提供了特别的语法，形如 `type[]`，像这样：

```ts
let a: number[] = [];
```

可以看到，这个语法假定一个数组的元素全都是某种类型。

如果想使用联合类型等较复杂的类型来描述元素，需要用括号进行包裹，像这样：

```ts
let a: (number | string)[] = [];
```

你也可以简单的定义多维数组，直接嵌套`[]` 即可：

```ts
let a: number[][] = [[1]];
```

数组也可以引用自身，这能创造出奇妙的东西：

```ts
type AnyDArray = number[] | AnyDArray[];
let a: AnyDArray = [[[[[[[[[[[[[[1]]]]]]]]]]]]]];
```

和之前的类型一样，ts 可以自行进行推导：

```ts
let b = [ 1 ]; // number[]
let c = [ 2, 'lhj']; // (string | number)[]
```

不过，如果数组是空的，ts 就毫无办法，在这种情况下，你必须手动声明类型，否则将无法使用这个数组：

```ts
let d = [];
d.push(1); // 类型为 'number' 的实际参数不能传给 'never' 类型的形式参数
let e: number[] = [];
e.push(1);
```

### 元组

另外一些时候，人们需要一系列定长的数组，来存储一组特定类型的内容，像这样：

```ts
let matches = [
    [ 1, 2, "a" ],
    [ 5, 8, "aaa" ],
]
```

对于这种情况，ts 提供了元组类型，元组类型的语法形如 `[ type1, type2, ... ]`，像这样：

```ts
let matches: [ number, number, string ][] = [
    [ 1, 2, "a" ],
    [ 5, 8, "aaa" ],
    [ 10, 12 ] // [ number, number ] 类型不能赋值给 [ number, number, string ]
]
```

元组类型不会被自动推导，因此你必须使用类型标注或者类型断言进行处理：

```ts
let a: [ number, number ] = [ 1, 2 ];
let b = () => [ 1, 1 ] as [ number, number ];
```

特别的，你可以在类型后面加 `?` 表示这是一个可选元素：

```ts
let matches: [ number, number, string? ][] = [
    [ 1, 2, "a" ],
    [ 5, 8, "aaa" ],
    [ 10, 12 ] // 无事发生
]
```

你也可以给元素起名，以提高可读性，此时可选元素要写成和参数类似的 `?:` 形式：

```ts
let matches: [ start: number, end: number, text?: string ][] = [
    [ 1, 2, "a" ],
    [ 5, 8, "aaa" ],
    [ 10, 12 ]
]
```

注意，ts 要求你必须给所有元素都起名，或者不起名。

ts 还允许你定义剩余元素的类型，语法类似这样：[ type1, type2, ..., typen, ...restType ]，注意，由于剩下的元素是个数组，因此你定义的类型也必须是个数组：

```ts
let staticArray: [ number, ...string[] ] = [ 1, "5", "6" ];
```
