# 第四节 类型演算

## 泛型

类型演算是 tyepscript 的核心能力，这个能力使得你可以对类型进行计算。很少有语言拥有像 TS 一样强大的类型演算能力，不过强大的另一面就是难以理解，因此，在真正进入类型演算的讲解之前，我们先来看一下它的一个常用形态——泛型，相比于类型演算，泛型常见的多，几乎没有什么语言是没有泛型的（go：有事吗？）。

所谓的泛型，可以理解为一种函数，它只作用于类型，其声明方式为`类型名<类型1, 类型2>`。例如，我们定义一个类型：

```ts
type Union<T, U> = T | U;
```

这样我们就定义了一个简单的泛型类型，它的意思是，传入两个类型`T` `U`，然后返回一个类型是传入的类型`T` `U`的联合类型`T | U`。例如，当我们使用它时：

```ts
type A = Union<string, number>; // A = string | number
```

上面说过，泛型相当于一个函数，这里传入了`string`和`number`，因此`A`的类型就是`string | number`了

### 函数的泛型

相比于`type`，在函数中使用泛型更为常见。例如，当我们设置了一个函数，它的功能是返回一个将所有传入的参数包装为数组时，如果不使用泛型，那么它应该是这样：

```ts
function toArray(...items: any[]): any[] {
    return [...items];
}
```

很显然，在经过上述函数的操作后，类型就会丢失，那么 ts 也将无法提示我们类型的错误，这显然是不好的，因此，我们可以使用泛型：

```ts
function toArray<T>(items: T[]): T[] {
    return [...items];
}
```

这里，泛型仍然相当于一个函数，`T`便是函数的参数。我们调用函数时，有两种方法：

```ts
const a = toArray<number>(1, 2, 3); // 指定传入泛型的参数，如果与后面的不匹配，会直接报错
const b = toArray(1, 2, 3); // 不指定，ts会自动帮你推导泛型，这是b的类型就是 number[]
```

### 默认值

上面我们说过，泛型相当于一个函数，因此它也有与函数类似的特性——默认值。我们知道，在 js 中，默认值使用`参数 = 默认值`的形式设置，在泛型中也一样：

```ts
type Union<T = any, U = any> = T | U;
```

这时，如果在使用这个类型时没有传入泛型，那么它的类型就会变成`any | any`，也就是`any`

```ts
type A = Union; // 由于我们没有传入泛型，因此A的类型是any
```

### 约束

一般情况下，你可以向泛型中传入任何类型，但是，很多时候我们不希望这样，因此我们需要泛型约束这个东西。它的使用方式如下：

```ts
type A<T extends string> = `Type is ${T}`;
```

这里暂且不说明模板字符串的用途。这里我们将 T 的类型限制为字符串，我们可以发现，如果传入 T 的类型不是字符串的话将会报错。这便符合了我们的预期。

### keyof

`keyof`是一个经常在泛型中出现的东西，一般它可以用来限制两个相互关联的类型，`addEventListener`是一个很好的例子。首先，对于`keyof`，顾名思义，它是取一个对象中的所有的键。例如：

```ts
interface EventMap {
    load: LoadEvent;
    blur: FocusEvent;
    focus: FocusEvent;
    click: MouseEvent;
    close: Event;
}

type EventKey = keyof EventMap;
```

这里我截取了 dom 事件的一部分。显然，`EventKey`的类型应该是`'load' | 'blur' | 'focus' | 'click' | 'close'`，这样我们就取到了一个对象中所有的键。那么，让我们让它与泛型结合一下：

```ts
function addEventListener<K extends keyof EventMap>(type: K, listener: (e: EventMap[K]) => void)
```

乍一看好像挺复杂的，我们一点点解释。首先，我们定义了一个泛型`K`，它的类型是`EventMap`中所有的键，然后函数的第一个参数`type`的类型是`K`，那么也就是说`type`我们只能填`'load' | 'blur' | 'focus' | 'click' | 'close'`中的一个。然后第二个参数是个函数，它有一个事件参数`e`，它的类型是`EventMap[K]`，那么这也就意味着，如果我们`type`填入了`load`，那么`e`的类型就会是`LoadEvent`，这样，类型就很完美了。

### 映射类型

之前你可能试过这样：

```ts
interface A {
    [x: EventKey]: any
}
```

但是很遗憾地发现，它会报错。为了解决这个问题，我们需要使用映射类型：

```ts
type B = {
    [T in EventKey]: any
}
```

这时，你发现 B 的键就是 EventKey 了！与此同时，你还发现它有一个`T`，那么这个`T`什么意思呢？注意到前面泛型中我们也经常使用`T`，那么也就是说它可能也是类型，事实也是这样，它表示`EventKey`中的每一个类型：

```ts
type C = {
    [T in EventKey]: T
}

/// 相当于

type D = {
    load: 'load'
    blur: 'blur'
    focus: 'focus'
    click: 'click'
    close: 'close'
}
```

对于一些修饰符，你可以通过`+`或`-`来进行添加或去除：

```ts
type E = {
    -readonly [T in EventKey]: T
}

type F = {
    readonly [T in EventKey]: T // 没有+或-，默认是+
}

type G = {
    [T in EventKey]-?: T
}
```

注意映射类型不能直接用于接口和类的第一级

### 结合结合再结合

我们可以把上面的所有东西结合起来，创造一个简易的事件系统：

```ts
interface EventMap {
    load: LoadEvent;
    blur: FocusEvent;
    focus: FocusEvent;
    click: MouseEvent;
    close: Event;
}

type Listener<T extends Key> = (e: EventMap[T]) => void

type ListnerMap = {
    [T in Key]: Listener<T>
}

type Key = keyof EventMap

class EventTarget {

    private listeners: ListenerMap

    constructor()

    on<K extends Key>(type: K, listener: Listener<K>): void

    off<K extends Key>(type: K, listener: Listener<K>): void

    dispatch<K extends Key>(type: K, e: EventMap[K]): void
}
```

### 泛型类

显然，上面的EventTarget是要被继承的，但如果我们按照上面的写法来，所有的东西的事件都是一样的，因此我们还需要一个东西：泛型类。它与其它的泛型用法完全相同，于是我们可以改进一下上面的事件系统：

```ts
type EventMap<K extends string | symbol | number> = {
    [T in K]: Event;
}

type Listener<T extends keyof E, E extends EventMap<keyof E>> = (e: E[T]) => void;

type ListenerMap<E extends EventMap<keyof E>> = {
    [T in keyof E]: Listener<T, E>;
};

class EventTargetA<E extends EventMap<keyof E>> {
    private listeners: ListenerMap<E>;

    constructor()

    on<K extends keyof E>(type: K, listener: Listener<K, E>): void

    off<K extends keyof E>(type: K, listener: Listener<K, E>): void

    dispatch<K extends keyof E>(type: K, e: E[K]): void
}
```

这样，这个事件系统就比较完美了，可以解决绝大多数情况下的类型问题。如果不能理解的话建议慢慢研究，核心依然是泛型。

## 类型演算

如果你已经接受了上面的内容，那么我们不妨突进一下想象力，既然函数，接口和类可以使用泛型，也许 `type` 也可以，实际上的确如此，而且这个操作的后果远超想象，例如说，ts 内置了这样的 Type：

```ts
interface Option {
    prop1: number;
    prop2: number;
}
let i: Partial<Option> = { prop1: 1 }; // Partial<Option>
```

这个 `Partial` 类型的作用是，将一个对象的所有属性都变成可选的，也就是说，i 实际的类型像是这样：

```ts
interface Partial_Option {
    prop1?: number;
    prop2?: number;
}
```

通过上述泛型的学习，你可能会意识到，`Partial`的本质就是：

```ts
type Partial<T> = {
    [P in keyof T]?: T[P]
}
```

除了`Partial`这个东西，ts 本身还为我们提供了这些东西：

### Required

它可以让一个对象中的所有项都变成必选的：

```ts
interface Option {
    prop1?: number;
    prop2?: number;
}
let i: Required<Option> = { prop1: 1, prop2: 2 }; // 所有项都必选
```

它的本质是

```ts
type Required<T> = {
    [P in keyof T]-?: T[P] 
}
```

### Readonly

将所有项变成只读的，本质是：

```ts
type Readonly<T> = {
    readonly [P in keyof T]: T
}
```

### Pick

从一个对象中挑选出一些项拿出来：

```ts
type A = {
    num: number
    str: string
    bool: boolean
}

type B = Pick<A, 'num' | 'str'>

//// B的类型就是：

type B = {
    num: number
    str: string
}
```

### Record

类似于映射类型

```ts
type A = Record<'a' | 'b', number>

//// 等价于

type A = {
    [T in 'a' | 'b']: number
}
```

本质：

```ts
type Record<K extends keyof any, T> = {
    [P in K]: T;
}
```

### NonNullable

除去类型中的undefined和null

```ts
type A = NonNullable<number | undefined> // A的类型是number
```

本质：

```ts
type NonNullable<T> = T & {}
```

因为null和undefined上面没有属性，所以会被剔除掉，这个有点难理解

### extends 表达式

这里的extends与泛型的extends不同，在这里，extends用于判断一个类型是否可以分配给另一个类型，它一定以三元表达式的形式出现：

```ts
type A = number

type B = A extends number ? true : never
```

这里，B的意思是，如果A的类型可以分配给number，那么B的类型就是true，否则就是never。在对联合类型使用此操作时，ts会将联合类型展开并逐个进行比对：

```ts
type A = 'a' | 'b' | 'c' | 1 | 2

type B = A extends string ? A : never
```

这里，A的五个类型会逐个判断是否可以分配给string类型，然后将每个判断结果整合成一个新的联合类型。因此，B的类型为`'a' | 'b' | 'c'`

有了extends表达式，我们又可以干一些有意思的事情：

### Extract

从一个类型中选择一部分类型，正如我们上面的那个例子

```ts
type A = Exclude<'a' | 'b' | 'c' | 1 | 2, string> // 'a' | 'b' | 'c'
```

本质：

```ts
type Extract<T, U> = T extends U ? T : never
```

### Exclude

从一个类型中剔除一部分类型，与Extract正好相反

```ts
type A = Exclude<'a' | 'b' | 'c' | 1 | 2, string> // 1 | 2
```

本质：

```ts
type Exclude<T, U> = T extends U ? never : T
```

### Omit

从一个对象中剔除一部分属性，与Pick相反

```ts
type A = {
    num: number
    str: string
    bool: boolean
}

type B = Omit<A, 'bool' | 'num'> // { str: string }
```

本质：

```ts
type Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>
```

### typeof

表示获得某个变量或常量的类型

```ts
const arr = [1, 2, 3];
type A = typeof arr // number[]
```

### infer

infer是一个很难理解的东西，也不是很常用，但在某些地方有很大的用途。它一定在extends后出现，这意味着它也一定伴随着三元表达式出现。它表示推断extends之前对应位置的类型，并生成一个推断类型，在之后可以使用它。如果推断成功，就会返回:之前的类型，否则就是:之后的类型。这么说可能不好理解，我们先看一个例子：

```ts
type A = number

type B = A extends infer P ? P : never
```

这个是什么意思呢？我们这样理解，首先infer表示推断与extends前相同位置的类型，那么P的类型就是A了，因为推断成功，所以B的类型就是P，也就是A，也就是number。下面我们看一个稍微复杂的例子：

```ts
const arr = [1, 2, 3];

type A = typeof arr

type B = A extends Array<infer P> ? Record<number, P> : any
```

我们从上面知道了infer可以直接推断类型，但除此之外，它还能推导泛型，正如上面的例子。首先arr是一个数组，它的类型是`number[]`，也就是`Array<number>`，从上面的描述中我们知道，infer用于推断对应位置的类型，因此infer就会推断`Array<这里的类型>`，然后把类型赋给P。很显然，上述例子中的推断是成立的，因此B的类型就是`Record<number, P>`，推断出的P的类型是number，因此B的类型就是`Record<number, number>`

### is

is是只能在函数返回值中出现的运算符，它用于判断一个参数是否是一个类型。例如：

```ts
function has<T>(value: T): value is NonNullable<T>
```

它的返回值是一个布尔型。当然，ts不管你是怎么实现的，只要返回值是一个布尔型就能通过类型检查。它的返回值表示`value`是否是将`undefined`排除后的`T`，这意味着这个函数可以用于判断一个量是否一定存在：

```ts
function fn(v?: number) {
    if (has(v)) {
        // 这里是当v存在的时候
    } else {
        // 这里是当v不存在的时候
    }
}
```

有了infer和is，我们就可以创造出来一个更为奇妙的东西

### Parameters

用于获得一个函数的所有参数：

```ts
function toArray(...args: number[]): number[]

type A = Parameters<typeof toArray> // number[]

function toArray2(a: number, b: string): [number, string]

type B = Parameters<typeof toArray2> // [a: number, b: string]
```

本质：

```ts
type Parameters<T extends (...args: any) => any> = T extends (...args: infer P) => any ? P : never
```

### ReturnType

用于获取一个函数的返回值

```ts
function test(a: any, b: any): boolean

type A = ReturnType<typeof test> // boolean
```

本质：

```ts
type ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : any
```

### 模板字符串

通过上述的教学，我们发现ts处理字符串的能力很弱。为此，ts还提供了一个模板字符串的功能，它能让字符串之间相互组合：

```ts
type A = '1' | '2' | '3' | '4'

type B = 'a' | 'b' | 'c' | 'd'

type C = `${B},${A}` // 包含了B和A的所有16种组合
```

### 字符串处理

ts内置了四种能够处理字符串的类型：

1. `Uppercase<S extends string>`把字符串变成大写
2. `Lowercase<S extends string>`把字符串变成小写
3. `Capitalize<S extends string>`把首字母变成大写
4. `Uncapitalize<S extends string>`把首字母变成小写

由于这些类型很难或不能使用ts的类型演算做到，因此它们都使用了ts的内置处理工具进行处理

### as

在映射类型中，你还可以使用as进行重分配类型，例如：

```ts
type Getters<T> = {
    [P in keyof T as `get${Capitalize<string & P>}`]: () => T[P]
}; // 这里将P重新分配给了`get${Capitalize<string & P>}`，也就是说，如果P的类型是'name'，那么重新分配后的类型就是getName，
// 那么也就是说Getters的所有属性名都会是  get+首字母大写的原来的属性名
 
interface Person {
    name: string;
    age: number;
    location: string;
}
 
type LazyPerson = Getters<Person>;
// type LazyPerson = {
//     getName: () => string;
//     getAge: () => number;
//     getLocation: () => string;
// }
```

### new

上面说过，映射类型不能直接用于类和接口的第一级，接口可以用type代替，但是类没有可以代替的。为此，我们可以使用`new`运算符来实现。`new`运算符用于声明一个构造函数：

```ts
type Constructor = new (...args: any) => {}
```

你会发现它可以声明一个返回值，那么这不就是说我们可以在里面使用映射类型了！

```ts
type C = new () => {
    [T in keyof Person]: Person[T]
}
```

这下，类里面也可以使用映射类型了，我们就能干更多的事了

## 黑魔法

到此为止，恭喜你已经学会了ts的几乎所有东西（还有枚举、迭代等没学，但问题不大），那么，你可以用这些东西搞出来各种神秘的东西出来。现在我可以很认真地告诉你：ts的类型系统是图灵完备的，也就是说，它可以干任何计算机能干的事（当然绘制可能做不到，但是搞点象棋魔塔什么的还是可以的。那么就让我们把目前学到的所有东西结合起来吧！

### 函数转发

首先我们需要几个挂载到core上的实例，这里随便搞了点作为示例

```ts
class Control {
    constructor()

    debug(): void

    removeFlag(name: string): void
}

class Events {
    constructor()

    startGame(hard: string, seed: number, route: string, callback?: () => void): void

    gameOver(ending?: string, fromReplay?: boolean, norank?: boolean): void
}

class Actions {
    constructor()

    doAction(): void
}

class Core {
    events: Events
    control: Control

    constructor()
}
```

这样，我们成功地将两个实例挂载到了core上，下一步我们需要进行转发。

首先我们先思考一下转发的流程。第一步，获取要转发的实例中的所有键，并筛选出函数。第二步，将这些函数挂载到core上。经过“简单”的分析，我们可以得到以下代码：

```ts
type Forward<T> = {
    [K in keyof T as T[K] extends Function ? K : never]: T[K];
};

type Forwarded = Forward<Control> & Forward<Events> & Forward<Actions>;

type CoreInstance = Core & Forwarded;

function forward(core: Core, ...ins: (new () => any)[]): CoreInstance {
    const f: Partial<Forwarded> = {};
    for (const i of ins) {
        // forward
    }
    return Object.assign({}, core, f as Forwarded);
}

const core = forward(new Core(), Control);
```

### 四则运算

首先我们先来讲一下迭代。我们知道，在es6中，js出现了迭代器这个东西，这使得很多操作变得极为简单，例如扩散运算符：`[...arr]`，而ts的元组也可以这样，那么，这说明元组是可以叠加的，同时ts可以推断出元组的长度，从而让我们可以通过操作元组来实现四则运算（当然负数不行）。首先我们来看如何推断元组的长度：

```ts
type A = [1, 1, 1]['length']
```

那么，首先我们要根据一个数创建一个对应长度的元组的类型

```ts
type A<Length, Now extends number[]> = Now['length'] extends Length ? Now : A<Length, [1, ...Now]>;
type Arr<N extends number> = number extends N ? 1[] : A<N, []>;
```

对于生成数组，它一定是从0开始向上增加的，因此只要判断是否等于目标长度就行了。下面，我们就能用这些东西搞出来加法了

```ts
type Add<A extends number, B extends number> = [...Arr<A>, ...Arr<B>]['length']
```

很神奇吧（，下面来看减法，首先我们进行一下简单的数学运算：减法的运算为：差 = 被减数 - 减数，那么 被减数 = 减数 + 差，因此，我们可以使用infer推断出差值：

```ts
type Sub<A extends number, B extends number> = Arr<A> extends [...Arr<B>, ...infer R] ? R['length'] : never;
```

事情逐渐变得奇妙了起来，下面让我们来做乘法。乘法就是A个B相加，本质上还是加法，每加一次就让其中一个数减一，运用递归即可

```ts
type _Multi<A extends number, B extends number, Now extends unknown[]> = B extends 0 ? Now['length'] : _Multi<A, Sub<B, 1>, [...Now, ...Arr<A>]>
```

还有一个除法，转换为数组思路为长度为 m 的数组由多少个长度为 n 的数组组成

```ts
type _Divide<A extends number, B extends number, Now extends 1[][]> = A extends 0 ? Now['length'] : _Divide<Sub<A, B>, B, [Arr<B>, ...Now]>
type Divide<A extends number, B extends number> = _Divide<A, B, []>
```

那么，四则运算现在你已经学会了，那么下面让我们来做点尝试（，我们声明一个函数，它的功能是把10进制rgb转换为16进制，那么类型怎么写呢？

答案：

```ts
// 带余除法
type _DivideBy<A extends number, B extends number, Now extends unknown[]> =
    Sub<A, B> extends never
        ? [ Now["length"], A ]
        : _DivideBy<Sub<A, B>, B, [unknown, ...Now]>
type DividedBy<A extends number, B extends number> = _DivideBy<A, B, []>;

type HexCharacters = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'];
type HexCharacter<T extends number> = HexCharacters[T];

type TwoDigitHex<T extends [ number, number ]> = `${ HexCharacter<T[0]> }${ HexCharacter<T[1]>}`;
type NumberToHex<T extends number> = TwoDigitHex<DividedBy<T, 16>>;

declare function rgbToHex<R extends number, G extends number, B extends number>(r: R, g: G, b: B): `#${ NumberToHex<R> }${ NumberToHex<G> }${ NumberToHex<B> }`;
```