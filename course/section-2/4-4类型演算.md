# 第三节 类型演算

## 泛型

类型演算是 tyepscript 的核心能力，这个能力使得你可以对类型进行计算。很少有语言拥有像 TS 一样强大的类型演算能力，不过强大的另一面就是难以理解，因此，在真正进入类型演算的讲解之前，我们先来看一下它的一个常用形态——泛型，相比于类型演算，泛型常见的多，几乎没有什么语言是没有泛型的（go：有事吗？）。

所谓的泛型，指的是，一个最常见

### 默认值



### 约束



## 类型演算

如果你已经接受了上面的内容，那么我们不妨突进一下想象力，既然函数，接口和类可以使用泛型，也许 `type` 也可以，实际上的确如此，而且这个操作的后果远超想象，例如说，ts 内置了这样的 Type：

```ts
interface Option {
    prop1: number;
    prop2: number;
}
let i: Partial<Option> = { prop1: 1 }; // Partial<Option>
```

这个 `Partial` 类型的作用是，将一个对象的所有属性都变成可选的，也就是说，i 实际的类型像是这样：

```ts
interface Partial_Option {
    prop1?: number;
    prop2?: number;
}
```

也许你已经发现了事情的奇妙之处，我们可以将基于 `type` 的泛型用于

### extends 表达式

### infer

### 模板字符串

### 黑魔法


