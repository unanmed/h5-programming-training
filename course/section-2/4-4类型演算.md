# 第四节 类型演算

## 泛型

类型演算是 tyepscript 的核心能力，这个能力使得你可以对类型进行计算。很少有语言拥有像 TS 一样强大的类型演算能力，不过强大的另一面就是难以理解，因此，在真正进入类型演算的讲解之前，我们先来看一下它的一个常用形态——泛型，相比于类型演算，泛型常见的多，几乎没有什么语言是没有泛型的（go：有事吗？）。

所谓的泛型，可以理解为一种函数，它只作用于类型，其声明方式为`类型名<类型1, 类型2>`。例如，我们定义一个类型：

```ts
type Union<T, U> = T | U;
```

这样我们就定义了一个简单的泛型类型，它的意思是，传入两个类型`T` `U`，然后返回一个类型是传入的类型`T` `U`的联合类型`T | U`。例如，当我们使用它时：

```ts
type A = Union<string, number>; // A = string | number
```

上面说过，泛型相当于一个函数，这里传入了`string`和`number`，因此`A`的类型就是`string | number`了

### 函数的泛型

相比于`type`，在函数中使用泛型更为常见。例如，当我们设置了一个函数，它的功能是返回一个将所有传入的参数包装为数组时，如果不使用泛型，那么它应该是这样：

```ts
function toArray(...items: any[]): any[] {
    return [...items];
}
```

很显然，在经过上述函数的操作后，类型就会丢失，那么 ts 也将无法提示我们类型的错误，这显然是不好的，因此，我们可以使用泛型：

```ts
function toArray<T>(items: T[]): T[] {
    return [...items];
}
```

这里，泛型仍然相当于一个函数，`T`便是函数的参数。我们调用函数时，有两种方法：

```ts
const a = toArray<number>(1, 2, 3); // 指定传入泛型的参数，如果与后面的不匹配，会直接报错
const b = toArray(1, 2, 3); // 不指定，ts会自动帮你推导泛型，这是b的类型就是 number[]
```

### 默认值

上面我们说过，泛型相当于一个函数，因此它也有与函数类似的特性——默认值。我们知道，在 js 中，默认值使用`参数 = 默认值`的形式设置，在泛型中也一样：

```ts
type Union<T = any, U = any> = T | U;
```

这时，如果在使用这个类型时没有传入泛型，那么它的类型就会变成`any | any`，也就是`any`

```ts
type A = Union; // 由于我们没有传入泛型，因此A的类型是any
```

### 约束

一般情况下，你可以向泛型中传入任何类型，但是，很多时候我们不希望这样，因此我们需要泛型约束这个东西。它的使用方式如下：

```ts
type A<T extends string> = `Type is ${T}`;
```

这里暂且不说明模板字符串的用途。这里我们将 T 的类型限制为字符串，我们可以发现，如果传入 T 的类型不是字符串的话将会报错。这便符合了我们的预期。

### keyof

`keyof`是一个经常在泛型中出现的东西，一般它可以用来限制两个相互关联的类型，`addEventListener`是一个很好的例子。首先，对于`keyof`，顾名思义，它是取一个对象中的所有的键。例如：

```ts
interface EventMap {
    load: LoadEvent;
    blur: FocusEvent;
    focus: FocusEvent;
    click: MouseEvent;
    close: Event;
}

type EventKey = keyof EventMap;
```

这里我截取了 dom 事件的一部分。显然，`EventKey`的类型应该是`'load' | 'blur' | 'focus' | 'click' | 'close'`，这样我们就取到了一个对象中所有的键。那么，让我们让它与泛型结合一下：

```ts
function addEventListener<K extends keyof EventMap>(type: K, listener: (e: EventMap[K]) => void)
```

乍一看好像挺复杂的，我们一点点解释。首先，我们定义了一个泛型`K`，它的类型是`EventMap`中所有的键，然后函数的第一个参数`type`的类型是`K`，那么也就是说`type`我们只能填`'load' | 'blur' | 'focus' | 'click' | 'close'`中的一个。然后第二个参数是个函数，它有一个事件参数`e`，它的类型是`EventMap[K]`，那么这也就意味着，如果我们`type`填入了`load`，那么`e`的类型就会是`LoadEvent`，这样，类型就很完美了。

### 映射类型

之前你可能试过这样：

```ts
interface A {
    [x: EventKey]: any
}
```

但是很遗憾地发现，它会报错。为了解决这个问题，我们需要使用映射类型：

```ts
type B = {
    [T in EventKey]: any
}
```

这时，你发现 B 的键就是 EventKey 了！。与此同时，你还发现它有一个`T`，那么这个`T`什么意思呢？注意到前面泛型中我们也经常使用`T`，那么也就是说它可能也是类型，事实也是这样，它表示`EventKey`中的每一个类型：

```ts
type C = {
    [T in EventKey]: T
}

/// 相当于

type D = {
    load: 'load'
    blur: 'blur'
    focus: 'focus'
    click: 'click'
    close: 'close'
}
```

注意映射类型不能直接用于接口的第一级

### 结合结合再结合

我们可以把上面的所有东西结合起来，创造一个简易的事件系统：

```ts
interface EventMap {
    load: LoadEvent;
    blur: FocusEvent;
    focus: FocusEvent;
    click: MouseEvent;
    close: Event;
}

type Listener<T extends Key> = (e: EventMap[T]) => void

type ListnerMap = {
    [T in Key]: Listener<T>
}

type Key = keyof EventMap

class EventTarget {

    private listeners: ListenerMap

    constructor()

    on<K extends Key>(type: K, listener: Listener<K>): void

    off<K extends Key>(type: K, listener: Listener<K>): void

    dispatch<K extends Key>(type: K, e: EventMap[K]): void
}
```

### 泛型类

显然，上面的EventTarget是要被继承的，但如果我们按照上面的写法来，所有的东西的事件都是一样的，因此我们还需要一个东西：泛型类。它与其它的泛型用法完全相同，于是我们可以改进一下上面的事件系统：

```ts
type EventMap<K extends string | symbol | number> = {
    [T in K]: Event;
}

type Listener<T extends keyof E, E extends EventMap<keyof E>> = (e: E[T]) => void;

type ListenerMap<E extends EventMap<keyof E>> = {
    [T in keyof E]: Listener<T, E>;
};

class EventTargetA<E extends EventMap<keyof E>> {
    private listeners: ListenerMap<E>;

    constructor()

    on<K extends keyof E>(type: K, listener: Listener<K, E>): void

    off<K extends keyof E>(type: K, listener: Listener<K, E>): void

    dispatch<K extends keyof E>(type: K, e: E[K]): void
}
```

这样，这个事件系统就比较完美了，可以解决绝大多数情况下的类型问题。如果不能理解的话建议慢慢研究，核心依然是泛型。

## 类型演算

如果你已经接受了上面的内容，那么我们不妨突进一下想象力，既然函数，接口和类可以使用泛型，也许 `type` 也可以，实际上的确如此，而且这个操作的后果远超想象，例如说，ts 内置了这样的 Type：

```ts
interface Option {
    prop1: number;
    prop2: number;
}
let i: Partial<Option> = { prop1: 1 }; // Partial<Option>
```

这个 `Partial` 类型的作用是，将一个对象的所有属性都变成可选的，也就是说，i 实际的类型像是这样：

```ts
interface Partial_Option {
    prop1?: number;
    prop2?: number;
}
```

通过上述泛型的学习，你可能会意识到，`Partial`的本质就是：

```ts
type Partial<T> = {
    [P in keyof T]?: T[P]
}
```

### extends 表达式

### infer

### 模板字符串

### 黑魔法
