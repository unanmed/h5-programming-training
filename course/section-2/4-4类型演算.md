# 第四节 类型演算

## 泛型

类型演算是 tyepscript 的核心能力，这个能力使得你可以对类型进行计算。很少有语言拥有像 TS 一样强大的类型演算能力，不过强大的另一面就是难以理解，因此，在真正进入类型演算的讲解之前，我们先来看一下它的一个常用形态——泛型，相比于类型演算，泛型常见的多，几乎没有什么语言是没有泛型的（go：有事吗？）。

所谓的泛型，可以理解为一种函数，它只作用于类型，其声明方式为`类型名<类型1, 类型2>`。例如，我们定义一个类型：

```ts
type Union<T, U> = T | U;
```

这样我们就定义了一个简单的泛型类型，它的意思是，传入两个类型`T` `U`，然后返回一个类型是传入的类型`T` `U`的联合类型`T | U`。例如，当我们使用它时：

```ts
type A = Union<string, number>; // A = string | number
```

上面说过，泛型相当于一个函数，这里传入了`string`和`number`，因此`A`的类型就是`string | number`了

### 函数的泛型

相比于`type`，在函数中使用泛型更为常见。例如，当我们设置了一个函数，它的功能是返回一个将所有传入的参数包装为数组时，如果不使用泛型，那么它应该是这样：

```ts
function toArray(...items: any[]): any[] {
    return [...items];
}
```

很显然，在经过上述函数的操作后，类型就会丢失，那么 ts 也将无法提示我们类型的错误，这显然是不好的，因此，我们可以使用泛型：

```ts
function toArray<T>(items: T[]): T[] {
    return [...items];
}
```

这里，泛型仍然相当于一个函数，`T`便是函数的参数。我们调用函数时，有两种方法：

```ts
const a = toArray<number>(1, 2, 3); // 指定传入泛型的参数，如果与后面的不匹配，会直接报错
const b = toArray(1, 2, 3); // 不指定，ts会自动帮你推导泛型，这是b的类型就是 number[]
```

### 默认值

上面我们说过，泛型相当于一个函数，因此它也有与函数类似的特性——默认值。我们知道，在 js 中，默认值使用`参数 = 默认值`的形式设置，在泛型中也一样：

```ts
type Union<T = any, U = any> = T | U;
```

这时，如果在使用这个类型时没有传入泛型，那么它的类型就会变成`any | any`，也就是`any`

```ts
type A = Union; // 由于我们没有传入泛型，因此A的类型是any
```

### 约束

一般情况下，你可以向泛型中传入任何类型，但是，很多时候我们不希望这样，因此我们需要泛型约束这个东西。它的使用方式如下：

```ts
type A<T extends string> = `Type is ${T}`;
```

这里暂且不说明模板字符串的用途。这里我们将 T 的类型限制为字符串，我们可以发现，如果传入 T 的类型不是字符串的话将会报错。这便符合了我们的预期。

### keyof

`keyof`是一个经常在泛型中出现的东西，一般它可以用来限制两个相互关联的类型，`addEventListener`是一个很好的例子。首先，对于`keyof`，顾名思义，它是取一个对象中的所有的键。例如：

```ts
interface EventMap {
    load: LoadEvent;
    blur: FocusEvent;
    focus: FocusEvent;
    click: MouseEvent;
    close: Event;
}

type EventKey = keyof EventMap;
```

这里我截取了 dom 事件的一部分。显然，`EventKey`的类型应该是`'load' | 'blur' | 'focus' | 'click' | 'close'`，这样我们就取到了一个对象中所有的键。那么，让我们让它与泛型结合一下：

```ts
function addEventListener<K extends keyof EventMap>(type: K, listener: (e: EventMap[K]) => void)
```

乍一看好像挺复杂的，我们一点点解释。首先，我们定义了一个泛型`K`，它的类型是`EventMap`中所有的键，然后函数的第一个参数`type`的类型是`K`，那么也就是说`type`我们只能填`'load' | 'blur' | 'focus' | 'click' | 'close'`中的一个。然后第二个参数是个函数，它有一个事件参数`e`，它的类型是`EventMap[K]`，那么这也就意味着，如果我们`type`填入了`load`，那么`e`的类型就会是`LoadEvent`，这样，类型就很完美了。

### 映射类型

之前你可能试过这样：

```ts
interface A {
    [x: EventKey]: any
}
```

但是很遗憾地发现，它会报错。为了解决这个问题，我们需要使用映射类型：

```ts
type B = {
    [T in EventKey]: any
}
```

这时，你发现 B 的键就是 EventKey 了！与此同时，你还发现它有一个`T`，那么这个`T`什么意思呢？注意到前面泛型中我们也经常使用`T`，那么也就是说它可能也是类型，事实也是这样，它表示`EventKey`中的每一个类型：

```ts
type C = {
    [T in EventKey]: T
}

/// 相当于

type D = {
    load: 'load'
    blur: 'blur'
    focus: 'focus'
    click: 'click'
    close: 'close'
}
```

注意映射类型不能直接用于接口的第一级

### 结合结合再结合

我们可以把上面的所有东西结合起来，创造一个简易的事件系统：

```ts
interface EventMap {
    load: LoadEvent;
    blur: FocusEvent;
    focus: FocusEvent;
    click: MouseEvent;
    close: Event;
}

type Listener<T extends Key> = (e: EventMap[T]) => void

type ListnerMap = {
    [T in Key]: Listener<T>
}

type Key = keyof EventMap

class EventTarget {

    private listeners: ListenerMap

    constructor()

    on<K extends Key>(type: K, listener: Listener<K>): void

    off<K extends Key>(type: K, listener: Listener<K>): void

    dispatch<K extends Key>(type: K, e: EventMap[K]): void
}
```

### 泛型类

显然，上面的EventTarget是要被继承的，但如果我们按照上面的写法来，所有的东西的事件都是一样的，因此我们还需要一个东西：泛型类。它与其它的泛型用法完全相同，于是我们可以改进一下上面的事件系统：

```ts
type EventMap<K extends string | symbol | number> = {
    [T in K]: Event;
}

type Listener<T extends keyof E, E extends EventMap<keyof E>> = (e: E[T]) => void;

type ListenerMap<E extends EventMap<keyof E>> = {
    [T in keyof E]: Listener<T, E>;
};

class EventTargetA<E extends EventMap<keyof E>> {
    private listeners: ListenerMap<E>;

    constructor()

    on<K extends keyof E>(type: K, listener: Listener<K, E>): void

    off<K extends keyof E>(type: K, listener: Listener<K, E>): void

    dispatch<K extends keyof E>(type: K, e: E[K]): void
}
```

这样，这个事件系统就比较完美了，可以解决绝大多数情况下的类型问题。如果不能理解的话建议慢慢研究，核心依然是泛型。

## 类型演算

如果你已经接受了上面的内容，那么我们不妨突进一下想象力，既然函数，接口和类可以使用泛型，也许 `type` 也可以，实际上的确如此，而且这个操作的后果远超想象，例如说，ts 内置了这样的 Type：

```ts
interface Option {
    prop1: number;
    prop2: number;
}
let i: Partial<Option> = { prop1: 1 }; // Partial<Option>
```

这个 `Partial` 类型的作用是，将一个对象的所有属性都变成可选的，也就是说，i 实际的类型像是这样：

```ts
interface Partial_Option {
    prop1?: number;
    prop2?: number;
}
```

通过上述泛型的学习，你可能会意识到，`Partial`的本质就是：

```ts
type Partial<T> = {
    [P in keyof T]?: T[P]
}
```

除了`Partial`这个东西，ts 本身还为我们提供了这些东西：

### Required

它可以让一个对象中的所有项都变成必选的：

```ts
interface Option {
    prop1?: number;
    prop2?: number;
}
let i: Required<Option> = { prop1: 1, prop2: 2 }; // 所有项都必选
```

它的本质是

```ts
type Required<T> = {
    [P in keyof T]-?: T[P] 
}
```

对于`-?`，就是去除?的意思

### Readonly

将所有项变成只读的，本质是：

```ts
type Readonly<T> = {
    readonly [P in keyof T]: T
}
```

### Pick

从一个对象中挑选出一些项拿出来：

```ts
type A = {
    num: number
    str: string
    bool: boolean
}

type B = Pick<A, 'num' | 'str'>

//// B的类型就是：

type B = {
    num: number
    str: string
}
```

### Record

类似于映射类型

```ts
type A = Record<'a' | 'b', number>

//// 等价于

type A = {
    [T in 'a' | 'b']: number
}
```

本质：

```ts
type Record<K extends keyof any, T> = {
    [P in K]: T;
}
```

### NonNullable

除去类型中的undefined和null

```ts
type A = NonNullable<number | undefined> // A的类型是number
```

本质：

```ts
type NonNullable<T> = T & {}
```

因为null和undefined上面没有属性，所以会被剔除掉，这个有点难理解

### extends 表达式

这里的extends与泛型的extends不同，在这里，extends用于判断一个类型是否可以分配给另一个类型，它一定以三元表达式的形式出现：

```ts
type A = number

type B = A extends number ? true : never
```

这里，B的意思是，如果A的类型可以分配给number，那么B的类型就是true，否则就是never。在对联合类型使用此操作时，ts会将联合类型展开并逐个进行比对：

```ts
type A = 'a' | 'b' | 'c' | 1 | 2

type B = A extends string ? A : never
```

这里，A的五个类型会逐个判断是否可以分配给string类型，然后将每个判断结果整合成一个新的联合类型。因此，B的类型为`'a' | 'b' | 'c'`

有了extends表达式，我们又可以干一些有意思的事情：

### Extract

从一个类型中选择一部分类型，正如我们上面的那个例子

```ts
type A = Exclude<'a' | 'b' | 'c' | 1 | 2, string> // 'a' | 'b' | 'c'
```

本质：

```ts
type Extract<T, U> = T extends U ? T : never
```

### Exclude

从一个类型中剔除一部分类型，与Extract正好相反

```ts
type A = Exclude<'a' | 'b' | 'c' | 1 | 2, string> // 1 | 2
```

本质：

```ts
type Exclude<T, U> = T extends U ? never : T
```

### Omit

从一个对象中剔除一部分属性，与Pick相反

```ts
type A = {
    num: number
    str: string
    bool: boolean
}

type B = Omit<A, 'bool' | 'num'> // { str: string }
```

本质：

```ts
type Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>
```

### typeof

表示获得某个变量或常量的类型

```ts
const arr = [1, 2, 3];
type A = typeof arr // number[]
```

### infer

infer是一个很难理解的东西，也不是很常用，但在某些地方有很大的用途。它一定在extends后出现，这意味着它也一定伴随着三元表达式出现。它表示推断extends之前对应位置的类型，并生成一个推断类型，在之后可以使用它。如果推断成功，就会返回:之前的类型，否则就是:之后的类型。这么说可能不好理解，我们先看一个例子：

```ts
type A = number

type B = A extends infer P ? P : never
```

这个是什么意思呢？我们这样理解，首先infer表示推断与extends前相同位置的类型，那么P的类型就是A了，因为推断成功，所以B的类型就是P，也就是A，也就是number。下面我们看一个稍微复杂的例子：

```ts
const arr = [1, 2, 3];

type A = typeof arr

type B = A extends Array<infer P> ? Record<number, P> : any
```

我们从上面知道了infer可以直接推断类型，但除此之外，它还能推导泛型，正如上面的例子。首先arr是一个数组，它的类型是`number[]`，也就是`Array<number>`，从上面的描述中我们知道，infer用于推断对应位置的类型，因此infer就会推断`Array<这里的类型>`，然后把类型赋给P。很显然，上述例子中的推断是成立的，因此B的类型就是`Record<number, P>`，推断出的P的类型是number，因此B的类型就是`Record<number, number>`

### is

is是只能在函数返回值中出现的运算符，它用于判断一个参数是否是一个类型。例如：

```ts
function has<T>(value: T): value is NonNullable<T>
```

它的返回值是一个布尔型。当然，ts不管你是怎么实现的，只要返回值是一个布尔型就能通过类型检查。它的返回值表示`value`是否是将`undefined`排除后的`T`，这意味着这个函数可以用于判断一个量是否一定存在：

```ts
function fn(v?: number) {
    if (has(v)) {
        // 这里是当v存在的时候
    } else {
        // 这里是当v不存在的时候
    }
}
```

有了infer和is，我们就可以创造出来一个更为奇妙的东西

### Parameters

用于获得一个函数的所有参数：

```ts
function toArray(...args: number[]): number[]

type A = Parameters<typeof toArray> // number[]

function toArray2(a: number, b: string): [number, string]

type B = Parameters<typeof toArray2> // [a: number, b: string]
```

本质：

```ts
type Parameters<T extends (...args: any) => any> = T extends (...args: infer P) => any ? P : never
```

### ReturnType

用于获取一个函数的返回值

```ts
function test(a: any, b: any): boolean

type A = ReturnType<typeof test> // boolean
```

本质：

```ts
type ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : any
```

### 模板字符串

通过上述的教学，我们发现ts处理字符串的能力很弱。为此，ts还提供了一个模板字符串的功能，它能让字符串之间相互组合：

```ts
type A = '1' | '2' | '3' | '4'

type B = 'a' | 'b' | 'c' | 'd'

type C = `${B},${A}` // 包含了B和A的所有16种组合
```

### 字符串处理

ts内置了四种能够处理字符串的类型：

1. `Uppercase<S extends string>`把字符串变成大写
2. `Lowercase<S extends string>`把字符串变成小写
3. `Capitalize<S extends string>`把首字母变成大写
4. `Uncapitalize<S extends string>`把首字母变成小写

由于这些类型很难或不能使用ts的类型演算做到，因此它们都使用了ts的内置处理工具进行处理

## 黑魔法
