# 箭头函数

在es6，新增了一种`箭头函数`,主要作用是简便的书写函数；

```js
// es5
var add = function(a,b){
    return a+b
}
// es6
let add = (a,b) => {
    return a+b
}
```

可以看到，`箭头函数`和普通函数之间的书写区别就是，不必书写`function`关键词，`(){}`中间插了一个箭头`=>`；

如果函数满足了一些特殊条件，`箭头函数`可以更简便的书写：

## 书写区别

### 单参数函数

如果函数有且仅有`1`个参数，箭头函数允许你省略`()`:

```js
// es5
var cheng = function(x){
	return x*2
}
// es6
let cheng = x => {
	return x*2
}
// x左右的()可以省略！
```

### 只有返回值的函数

如果函数体内部除了`return`语句之外，什么语句都没有，你可以省略`return`关键字和`{}`！

```js
// es5
var add = function(a,b){
	return a+b
}
// es6
let add = (a,b) => a+b
// return以及{}可以省略！
```

上述两个条件都满足的话，可以写出非常优雅的函数体：

```js
// es5
var cheng = function(x){
	return x*2
}
// es6
let cheng = x => x * 2
// 可以省略很多！
```

简洁明了，更像是数学中的函数！

## 其它区别

### 1.箭头函数不允许成为生成器函数

但可以成为异步函数

### 2.箭头函数没有名称

只允许赋值给变量(此时变量名便是箭头函数的名称)，或者直接当做值使用(视为一个函数值)

### 3.箭头函数没有自己的`this`

因为这个特性，所以它不能用作构造函数；这意味着你无法`new`一个箭头函数；

同时，因为它没有自己的`this`，就像作用域中的变量一样，规则完全相同：它会从上级找一个`this`当做它自己的`this`:

```js
let obj = {
    say(){
        console.log(this) // obj
        let x = function(){
            console.log(this) // 普通函数的this，严格模式下是undefined，非严格模式是window
        }
		x()
        // 如果我们改成箭头函数
        let y = ()=>{
            console.log(this) 
            // 箭头函数没有自己的this，它捕获了say的this作为它的this
            // say的this指向obj
            // 因此，输出obj
            (()=>()=>()=>console.log(this))()()()
            // 与作用域对变量的捕获规则一致，箭头函数也总是捕获离自己最近的那个作用域的this
            // 全是箭头函数！一级一级的往上找，最终找到say
            (function(){return ()=>()=>console.log(this)})()()()
            // 依照规则，离它最近的，有this的作用域是这个普通函数，普通函数是有自己的this的
            // 因此这里输出的是这个匿名函数的this
        }
        y()
    }
}
```

