# 作用域与const,let

## 作用域
首先让我们介绍一下`语句`和`表达式`的区别：

`语句`是一种行为，没有返回的值；

典型的`语句`是`for`循环以及`if`条件判断。

而`表达式`它会拥有返回值，所以能用在任何需要值的地方。

典型的`表达式`是`2+2`

作用域的概念非常简单，每一个`语句`内部都是一个不同的作用域；

作用域的规则同样简单：

### 子作用域能访问父作用域的变量，但父作用域不可访问子作用域的变量；

### 当多个上级作用域以及同级作用域都拥有同样的变量名时，作用域只会捕获离当前作用域最近的那一个

例如：
```js
// {}符号既可用于快速声明对象，亦可创建作用域
let a = 1 // 全局作用域
{
  let a = 2 // 全局作用域的子作用域
  if(true){
    console.log(a) 
    // if形成了一个作用域
    // 因此，if内部是全局作用域的子作用域的子作用域
    // 此时访问变量a
    // 离if作用域最近的变量a的值是2
    // 因此输出2
  }
}

```

## const与let

### let

为什么有了`var`还要使用`let`?

究其原因，是因为用`var`声明的变量是会被自动提升至全局作用域的！！

请看示例：

```js
{
  {
    {
      {
        {
          {
            {
              {
                {
                  var p = 2; // 一个超级子作用域内声明了变量p
                }
              }
            }
          }
        }
      }
    }
  }
}
p // 2
```
这合理吗？

不仅这个问题，`var`还有很多恶心的问题

因此，有了`let`关键词用于代替`var`；

`let`终于拥有自己的作用域了！它不会莫名其妙的跑到父作用域去；

它还防止了很多`var`自身的问题，因此，es6以后请不要再使用`var`而是使用`let`代替之！

### const

`const`与`let`相似之处在于，它和`let`一样安全；

不同点则在于，被`const`声明的变量是不可改变的！正如`const`的意义：`常量`

示例：
```js
const a = 2
a++ // 报错
a = 2 // 为常量重新赋值也是不允许的！ 报错
```
然而很可惜的是，`const`仍不能绝对保证变量不可变：

```js
const a = {a:1}
a.a = 2 // 不报错
const b = []
b.push(1) // 数组的push方法会改变原数组，但还是不报错
```
因此，其实`const`不能保证变量的`绝对不可变`，现在的`const`更像是告诉写维护代码的人,这块变量尽量不要变动，起象征作用；
