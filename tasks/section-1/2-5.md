# task1 计数

请编写一个函数，它可以接受任意多个参数，然后统计第二个参数开始的所有参数中，有多少个和第一个参数相同，并返回这个数量

```js init
/**
 * @template T
 * @param {T} target 目标值
 * @param {...T} var_args 参数
 * 
 * @return {number}
 */
function solution(target) {

}

// @judge-ignore
console.log(solution.apply(null, input));
```

```js input
[
    [ 1, 1, 9, 2, 6, 0, 8, 1, 7 ],
    [ "h5", "h5", "h6", "h7" ],
]
```

```js judger
function judge(target) {
    const args = Array.from(arguments);
    args.shift();
    let count = 0;
    args.forEach((e) => {
        if (e === target) count++;
    });
    return count;
}

assert(judge.apply(null, input) === judge.solution(null, input));
```

# task2 造轮子

在本节课中我们讲解了`map`函数，请你编写一个函数，它可以传入一个数组，以及一个回调函数，实现与`map`等价的功能

```js init
/**
 * @template T
 * @template K
 * @param {T[]} array 函数
 * @param {(elm: T, index: number, arr: T[]) => K } mapfn 回调函数
 * 
 * @return {number}
 */
function solution(target) {

}

// @judge-ignore
const [ array, rawfn ] = input;
console.log(solution(array, eval(rawfn)));
```

```js input
[
    [ [ 1, 2, 3 ], "(e, i) => e * i" ],
    [ [ 1, 2, 3 ], "(e, i, arr) => e * arr.at(i-1)" ],
    [ [ "1", "2", "3" ], "(e, i, arr) => parseInt(e)" ],
    [ [ 1, 2, 3 ], "(e, i, arr) => e.toString()" ],
    [ [ 1, 2, 3 ], "(e) => [e]" ]
]
```

```js judger
_map = Array.prototype.map;
Array.prototype.map = () => throw JudgeError("懒狗快爬");

const [ array, rawfn ] = input;
assert(equal(
    solution(array.concat(), eval(rawfn)),
    _map.apply(array.concat(), eval(rawfn)),
));

Array.prototype.map = _map;
```

<!--
# task2 地图模拟

在[梦](https://h5mota.com/tower?name=Dream)中有一个这样的关卡：角色只能向右或向上移动。现在请编写一个函数用于模拟这个情况，具体来说，这个函数会接收一个二维布尔数组，代表关卡的可通行矩阵，然后给出初始位置的`x`,`y`值，要求返回一个二维布尔数组，表示角色能到达的所有位置。特别的，数组的第一维代表`y`而第二维代表`x`, `x`值增大代表向右移动，`y`值减小代表向上移动

举例

```js
map = [
    [true, true],
    [false, true]
]
x = 1, y = 1
```

对于这组数据

```js
[
    [-,+],
    [-,*]
]
```

标`*`的位置即为角色初始位置，标`+`的为可到达的位置，而角色不能到达标`-`的两个位置，因为不能向左移动。

因此，输出应为

```js
[
    [false, true],
    [false, true]
]
```

保证初始位置永远是可通行的

```js init
/**
 * @template T
 * @param {boolean[][]} map 地图
 * @param {number} x 初始x坐标
 * @param {number} y 初始y坐标
 * 
 * @return {boolean[][]}
 */
function solution(map) {

}

// judge-ignore
console.log(solution.apply(null, input));
```

```js input
// function makeMap(x, y) {
//     const map = Array(y).fill().map(() => Array(x).fill().map(() => Math.random() > 0.3));
//     let sx, sy;
//     do {
//         sx = Math.floor(Math.random() * x);
//         sy = Math.floor(Math.random() * y);
//     } while (map[sy][sx]);
//     return JSON.stringify([map, sx, sy]);
// }
[
    [[
        [true,true],
        [false,true]
    ],1,1],
    [[
        [false,true],
        [true,false]
    ],0,1],
    [[
        [false,false,true,true],
        [true,false,false,true]
    ],2,1],
    [[
        [true,false,false,true,true,false,true,true],
        [true,false,true,true,true,false,false,false],
        [true,false,false,true,false,true,true,true],
        [false,true,true,true,false,true,false,true],
        [true,true,true,true,false,false,false,true],
        [false,true,false,false,true,false,false,true],
        [true,true,false,true,true,true,false,false],
        [true,true,true,true,true,false,true,false],
        [true,false,true,true,true,false,false,true],
        [false,false,true,true,true,true,true,false],
        [false,true,false,true,true,false,false,true],
        [true,true,false,true,true,true,true,true]
    ],0,5],
    [[
        [true,true,true,true,true,false,false,true,false,true,false,true],
        [true,true,true,false,false,true,false,true,true,false,false,true],
        [true,false,false,true,true,true,true,true,false,false,true,true],
        [true,false,true,false,false,true,false,false,true,false,true,true],
        [true,true,true,false,true,true,true,false,false,true,true,true],
        [true,false,true,true,true,true,true,false,true,false,false,false],
        [true,false,true,true,true,true,true,true,true,true,true,true],
        [true,true,false,false,false,true,true,true,false,true,true,true],
        [false,true,true,false,true,false,true,true,true,true,false,true],
        [true,true,true,true,true,false,true,true,true,true,true,false],
        [false,true,true,false,false,true,true,true,true,true,true,true],
        [false,true,true,false,true,false,false,true,true,false,true,true],
        [true,true,true,false,true,true,true,true,true,false,true,true],
        [true,true,true,true,false,true,true,true,true,true,false,false],
        [true,true,true,false,true,true,false,true,true,true,true,true],
        [true,true,true,false,true,true,false,true,false,true,false,true],
        [true,true,true,true,false,true,false,true,true,true,true,false],
        [false,false,false,false,true,true,true,false,true,true,true,true]
    ],0,15]
]
```

```js judger
function copy(a) {
    return JSON.parse(JSON.stringify(a));
}
function judge(map, x, y) {
    const mx = map[0].length, my = map.length;
    const ret = Array(my).fill().map(() => Array(mx).fill(false));
    for (var ny = my-1; ny > -1; ny--) {
        for (var nx = mx-1; nx > -1; nx--) {
            ret[ny][nx] = (() => {
                if (ny === my-1) return false;
                if (ny === y && nx === x) return true;
                if (ret[ny+1][nx]) return true;
                if (nx === nx-1) return false;
                if (ret[ny][nx-1]) return true;
                return false
            })();
        }
    }
}

const [ map, x, y ] = input
assert(equal(
    solution(copy(map), x, y),
    judge(copy(map), x, y),
));
```
-->

# task3 敏感词

众所周知，经常有神必人往网站上发奇怪的言论，现在希望你开发一个程序用以和谐用户的发言

具体来说，你需要编写一个名为`solution`的函数，它可以接受一个发言数组，每个数组由一个字符串数组组成，代表玩家的发言，一个敏感词列表，以及一个预定的和谐词，对于每个发言，你需要将其中所有的敏感词用和谐词来代替，特别的，如果一个发言中有5个及以上的词汇被和谐，或者全是敏感词，则将此发言从列表中删除，在处理完成后，请返回发言数组

```js init
/**
 * @template T
 * @param {string[][]} comments 发言列表
 * @param {string[]} censorlist 敏感词列表
 * @param {string} 和谐词
 * 
 * @return {string[][]}
 */
function solution(comments, censorlist, word) {

}

// judge-ignore
console.log(solution(input[0], input[1], input[2]));
```

```js input
[
    [ 
        [
            [ "LHJNB" ], [ "太难了" ], [ "太难了", "太难了", "太难了", "太难了", "太难了", "能不能简单点" ], [ "太难了", "能不能简单点" ]
        ],
        [ "太难了" ],
        "H5NB"
    ],
    [ 
        [
            [ "H5NB", "LHJNB" ], [ "H5SB" ], [ "H5SB", "LHJNB" ], [ "H5SB" ], [ "114514", "1919810" ],
        ],
        [ "H5SB" ],
        "H5NB"
    ],
    [ 
        [
            [ "H5NB", "LHJNB" ], [ "H5SB" ], [ "H5SB", "LHJNB" ], [ "H5SB" ], [ "114514", "1919810" ], [ "H5", "H5", "H6", "H6", "H6" ], [ "H5", "H5", "H6", "H6", "H6", "H7" ], 
        ],
        [ "H5", "h6" ],
        "H5NB"
    ],
    [ 
        [
            [ "H5NB", "LHJNB" ], [ "H5SB" ], [ "H5SB", "LHJNB" ], [ "H5SB" ], [ "114514", "1919810" ], [ "H5", "H5", "H6", "H6", "H6" ], [ "H5", "H5", "H6", "H6", "H6", "H7" ], [ "H5NB" ], [ "H5NB", "H5NB", "H5NB", "H5NB", "H5NB", "H5NB", "H5NB", "H6NB" ]
        ],
        [ "H5", "h6" ],
        "H5NB"
    ],
]
```

```js judger
function equal(a, b) {
    return JSON.stringify(a) === JSON.stringify(b);
}
function copy(a) {
    return JSON.parse(JSON.stringify(a));
}

function judge(comments, censorlist, word) {
    return comments
        .map((e) => e.map(w => {
            if (censorlist.includes(w)) return null;
            return w;
        }))
        .filter((e) => {
            let count = 0;
            for (let w of e) {
                if (w === null) count++;
            }
            return count < 5 && count < e.length;
        })
        .map((e) => e.map(w => {
            if (w === null) return word;
            return w;
        }))
}

const [ comments, censorlist, word ] = input;

assert(equal(
    solution(copy(comments), copy(censorlist) , word),
    judge(copy(comments), copy(censorlist) , word),
));
```

# task4 数组运算

我们为数组定义了一系列新的运算方法

具体来说

`+` 数组串接, 将数组b加到数组a后方 `"+" [ 1 ] [ 1, 2 ] -> [ 1, 1, 2 ]`

`*` 数组乘法, 将数组a中的每个元素乘以数组b中的每个元素，变成一个二维数组 `"*" [ 1 ] [ 1, 2 ] -> [ [ 1, 2 ] ]`

`&` 数组求交，返回数组a和数组b中都出现过的元素 `"&" [ 1 ] [ 1, 2 ] -> [ 1 ]`

`|` 数组求并，返回数组a和数组b中出现过的所有元素 `"|" [ 1 ] [ 1, 2 ] -> [ 1, 2 ]`

请你编写一个函数，接收运算符和两个数组，并返回运算结果

保证数组a, b 都是 `number` 型数组

```js init
/**
 * @template T
 * @param {"+"|"*"|"&"|"|"} operator 操作符
 * @param {number[]} a 数组a
 * @param {number[]} b 数组b
 * 
 * @return {number[]|number[][]}
 */
function solution(operator, a, b) {

}

// judge-ignore
console.log(solution(input[0], input[1], input[2]));
```

```js input
[
    [ "+", [ 1 ], [ 1, 2 ] ],
    [ "*", [ 1 ], [ 1, 2 ] ],
    [ "&", [ 1 ], [ 1, 2 ] ],
    [ "|", [ 1 ], [ 1, 2 ] ],
    [ "+", [ 1 ], [ 2 ] ],
    [ "*", [ 1 ], [ 2 ] ],
    [ "&", [ 1 ], [ 2 ] ],
    [ "|", [ 1 ], [ 2 ] ],
    [ "+", [ 1 ], [] ],
    [ "*", [ 1 ], [] ],
    [ "&", [ 1 ], [] ],
    [ "|", [ 1 ], [] ],
    [ "+", [ 1, 1, 2, 3 ], [ 2, 2, 3, 4 ] ],
    [ "*", [ 1, 1, 2, 3 ], [ 2, 2, 3, 4 ] ],
    [ "&", [ 1, 1, 2, 3 ], [ 2, 2, 3, 4 ] ],
    [ "|", [ 1, 1, 2, 3 ], [ 2, 2, 3, 4 ] ],
]
```

```js judger
function equal(a, b) {
    return JSON.stringify(a) === JSON.stringify(b);
}

function judge(operator, a, b) {
    const unique = (a) => {
        return a
            .sort((a, b) => a - b)
            .filter((e, i, arr) => {
                if (i === 0) return true;
                return arr[i] !== arr[i-1];
            });
    }
    switch(operator) {
        case "+": {
            return a.concat(b);
        }
        case "*": {
            return a.map(ae => b.map(be => ae * be));
        }
        case "&": {
            return unique(a).concat(unique(b))
                .sort((a, b) => a - b)
                .filter((e, i, arr) => {
                    if (i === 0) return false;
                    return arr[i] === arr[i-1];
                });
        }
        case "|": {
            return unique(a.concat(b));
        }
    }
}

const [ operator, a, b ] = input; 
if (["+", "*"].includes(operator)) {
    assert(
        equal(
            solution(operator, a.concat(), b.concat()),
            judge(operator, a.concat(), b.concat())
        )
    );
} else {
    assert(
        equal(
            solution(operator, a.concat(), b.concat()).sort((a, b) => a - b),
            judge(operator, a.concat(), b.concat()).sort((a, b) => a - b),
        )
    );
}
```
