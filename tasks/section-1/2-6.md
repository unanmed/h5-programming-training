# task1 榜单

请编写一个函数，接收一个提交记录数组，将其排序后返回，其中，提交记录是一个包含`user`, `score`, `timestamp` 三个`number`成员的对象。

排序的依据是，按照`score`降序排列，`score`相同时，`timestamp`值较小的排在前面

## 样例：

输入
```js
submissions = [
    {"user":114514,"score":3421,"timestamp":1645200174800}
    {"user":1015,"score":1677,"timestamp":1645200099707},
    {"user":1003,"score":3421,"timestamp":1545200174800},
]
```

输出
```js
[
    {"user":1003,"score":3421,"timestamp":555},
    {"user":114514,"score":3421,"timestamp":666}
    {"user":1015,"score":1677,"timestamp":555},
]
```

```js init
/**
 * @typedef {{ user: number, score: number, timestamp: number }} Submission
 * @param {Submissions[]} submissions
 * 
 * @return {Submissions[]}
 */
function solution(submissions) {

}

// @judge-ignore
console.log(solution(input));
```

```js input
const createSubmission = () => {
    const rand = (e) => ~~(Math.random() * e);
    const user = 1000 + rand(20);
    const score = Math.min(rand(10000), 8000);
    const timestamp = Date.now() - rand(1000000);
    return { user, score, timestamp };
}
[
    [{"user":1015,"score":1677,"timestamp":1645200099707},{"user":1003,"score":3421,"timestamp":1645200174800}],
    [{"user":1005,"score":3424,"timestamp":1645200753145},{"user":1005,"score":2209,"timestamp":1645200840133},{"user":1016,"score":8000,"timestamp":1645200211825},{"user":1011,"score":1809,"timestamp":1645200872663},{"user":1004,"score":8000,"timestamp":1645200373808},{"user":1008,"score":2438,"timestamp":1645200336857}],
    [{"user":1016,"score":2377,"timestamp":1645200787913},{"user":1017,"score":397,"timestamp":1645200669981},{"user":1007,"score":7395,"timestamp":1645200633154},{"user":1002,"score":8000,"timestamp":1645200790335},{"user":1000,"score":6296,"timestamp":1645200657962},{"user":1011,"score":5889,"timestamp":1645200443164},{"user":1016,"score":3103,"timestamp":1645200816940},{"user":1006,"score":2271,"timestamp":1645200586289},{"user":1013,"score":8000,"timestamp":1645200674558},{"user":1017,"score":5357,"timestamp":1645200634420}],
    Array(500).fill(0).map(e => createSubmission()),
    Array(1000).fill(0).map(e => createSubmission()),
]
```

```js judger
function judge(submissions) {
    return submissions.sort((a, b) => {
        if (a.score === b.score) {
            return a.timestamp - b.timestamp;
        } else {
            return b.score - a.score;
        }
    });
}

assert(equal(
    judge(input.concat()),
    solution(input.concat())
));
```

# task2 用户鉴权

请编写一个函数用于实现用户鉴权，具体来说，这个函数需要接收两个对象，代表用户拥有的权限和需要的权限，对象是一组`string`-`number`的键值对，如果对于需求权限中的每一项，用户都满足（即数值大于等于需求的数值），则返回`true`，否则返回`false`

例如，若用户拥有的权限为`{ dev: 2, tower: 1 }`, 则对于需求`{ dev: 2 }`满足要求，但是对于`{ tower: 2 }`, `{ bbs: 2 }`均不满足。

## 样例：

输入
```js
privilege = { dev: 2, tower: 1 }
need = { dev: 2, tower: 2 }
```

输出
```js
false
```

```js init
/**
 * @param {Record<string, number>} privilege 用户拥有的权限
 * @param {Record<string, number>} need 需要的权限
 * 
 * @return {boolean}
 */
function solution(privilege, need) {

}

// @judge-ignore
console.log(solution(input[0], input[1]));
```

```js input
[
    [ { dev: 2, tower: 1 }, { dev: 2 } ],
    [ { dev: 2, tower: 1 }, { tower: 2 } ],
    [ { dev: 2, tower: 1 }, { bbs: 2 } ],
    [ { dev: 2, tower: 1 }, { dev: 1, tower: 1 } ],
    [ { tower: 1 }, { dev: 1, tower: 1 } ],
    [ {}, { dev: 1 } ],
    [ {}, {} ],
]
```

```js judger
function judge(privilege, need) {
    for (let k in need) {
        if (!(k in privilege)) return false;
        if (need[k] > privilege[k]) return false;
    }
    return true;
}

const [ p, n ] = input;

assert(judge({ ...p }, { ...n }) === solution({ ...p }, { ...n }));
```

# task3 榜单改

在[task1](/codelab/task?id=36)的基础上，实现去重功能，即同一用户提交的成绩只保留最高的一个。

## 样例：

输入
```js
submissions = [
    {"user":114514,"score":3421,"timestamp":1645200174800},
    {"user":1003,"score":3421,"timestamp":1545200174800},
    {"user":1015,"score":1677,"timestamp":1645200099707},
    {"user":1015,"score":1077,"timestamp":1235200000000}
]
```

输出
```js
[
    {"user":1003,"score":3421,"timestamp":555},
    {"user":114514,"score":3421,"timestamp":666}
    {"user":1015,"score":1677,"timestamp":555},
]
```

```js init
/**
 * @typedef {{ user: number, score: number, timestamp: number }} Submission
 * @param {Submissions[]} submissions
 * 
 * @return {Submissions[]}
 */
function solution(submissions) {

}

// @judge-ignore
console.log(solution(input));
```

```js input
const createSubmission = () => {
    const rand = (e) => ~~(Math.random() * e);
    const user = 1000 + rand(20);
    const score = Math.min(rand(10000), 8000);
    const timestamp = Date.now() - rand(1000000);
    return { user, score, timestamp };
}
[
    [{"user":1015,"score":1677,"timestamp":1645200099707},{"user":1003,"score":3421,"timestamp":1645200174800}],
    [{"user":1005,"score":3424,"timestamp":1645200753145},{"user":1005,"score":2209,"timestamp":1645200840133},{"user":1016,"score":8000,"timestamp":1645200211825},{"user":1011,"score":1809,"timestamp":1645200872663},{"user":1004,"score":8000,"timestamp":1645200373808},{"user":1008,"score":2438,"timestamp":1645200336857}],
    [{"user":1016,"score":2377,"timestamp":1645200787913},{"user":1017,"score":397,"timestamp":1645200669981},{"user":1007,"score":7395,"timestamp":1645200633154},{"user":1002,"score":8000,"timestamp":1645200790335},{"user":1000,"score":6296,"timestamp":1645200657962},{"user":1011,"score":5889,"timestamp":1645200443164},{"user":1016,"score":3103,"timestamp":1645200816940},{"user":1006,"score":2271,"timestamp":1645200586289},{"user":1013,"score":8000,"timestamp":1645200674558},{"user":1017,"score":5357,"timestamp":1645200634420}],
    Array(500).fill(0).map(e => createSubmission()),
    Array(1000).fill(0).map(e => createSubmission()),
]
```

```js judger
function judge(submissions) {
    submissions = submissions.sort((a, b) => {
        if (a.score === b.score) {
            return a.timestamp - b.timestamp;
        } else {
            return b.score - a.score;
        }
    });
    const users = {}, _submissions = [];
    submissions.forEach((e) => {
        if (e.user in users) return;
        users[e.user] = true;
        _submissions.push(e);
    });
    return _submissions;
}

assert(equal(
    judge(input.concat()),
    solution(input.concat())
);
```

# task4 函数转发

请编写一个名为`solution`的函数，传入一个或若干个对象，每个对象中有各种数据类型的属性，你需要将这些属性筛选出来，筛选出是函数且函数名不以`_`开头的函数，合并成一个对象，并返回这个对象

## 样例：

输入
```js
input = [{
    a: 1,
    b: null,
    c: function () { return 1; },
    _d: function () { return 2 } 
}]
```

输出
```js
[{ c: function () { return 1; } }]
```

```js init
/** 
 * @returns {object} 
 */
function solution() {

}

// @judge-ignore
console.log(solution(eval(input)));
```

```js input
[
    `[{a: 1, b: null, c: () => 1, _d: () => 2 }]`,
    `[
        {
            search: (a) => a.match(/^abc(e|f|3)[0-9]*\s*$/)[0], 
            current: 5,
            time: 100,
            _map: (arr) => arr.map(v => v % 5 === 0)
        },
        {
            random: 'Math.random',
            random2: '(min, max) => Math.random() * (max - min) + min',
            ___: Math.random(),
            _random_random: '() => this.random2(-1, Math.random())'
        }
    ]`,
    `[{}]`,
    `[
        {},
        {
            func: new Function()
            },
        {
            _func: new Function("return 1")
        }
    ]`,
    `[]`,
    `[
        {
            a: 1, b: '2', c: true, d: null, e: void 0, f: {}
        },
        {a: {
            func: () => 1,
            func2: () => 2
        }}
    ]`
]
```

```js judger

_input = eval(input);

let length = 0;
_input.forEach(v => {
    length += Object.entries(v)
        .filter(v => {
            !v[0].startsWith('_') && typeof v[1] === 'function'
        }).length;
});

const res = solution(..._input);

function judge (a, b) {
    return Object.entries(a).every(v => Object.values(b).some(vv => v[0] in vv && v[1] === vv[v[0]]));
}

assert(Object.keys(res).length === length, '数量不正确！');
assert(judge(res, _input), '转发不正确！');
```
