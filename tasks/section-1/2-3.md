# task1 前缀和

请编写一个函数`solution`，接收一个数组arr，并返回它的前缀和，对于数组`a1, a2, a3...an`，它的前缀和是`s1, s2, s3...sn`，其中`sx = a1 + a2 + a3 ... ax`，举个例子，`[ 1, 2, 3 ]`的前缀和是`[ 1, 1+2, 1+2+3 ]` 即 `[ 1, 3, 6 ]`

```js init
/**
 * @template T
 * @param {T[]} array 要求前缀和的数组
 *
 * @return {T[]} 前缀和
 */
function solution(array) {

}

// judge-ignore
console.log(solution(input));
```

```js input
[
    [ 1, 2, 3 ],
    [ 1, 5, 4, 2, 3 ],
    [ 9, 8, 7, 6, 5, 4, 3, 2, 1 ],
    [ -10000, 9, 8, 7, 6, 5, 4, 3, 2, 1 ],
    [ 2, 1, 1 ],
]
```

```js judger
function judge(array) {
    const pre = [ 0 ];
    array.forEach((e, i) => {
        pre.push(pre[i] + e);
    });
    return pre.slice(1);
}

assert(equal(
    solution(input.concat()),
    judge(input.concat())
));
```

# task2 数组旋转

请编写一个函数`solution`，接收一个数组arr，以及一个可选的数字x，将传入的数组向右旋转x次（如果不传入x，则向右旋转1次），然后将其返回。其中，向右旋转指的是，将每个元素向后移动一次，最后一个元素的移动到开头，例如`[ 1, 5, 4, 2, 3 ]`向右旋转一次能得到`[ 3, 1, 5, 4, 2 ]`

```js init
/**
 * @template T
 * @param {T[]} array 要旋转的数组
 * @param {number} [x] 旋转的次数
 */
function solution(array, x) {
    
}

// judge-ignore
console.log(solution(input[0], input[1], input[2]));
```

```js input
[
    [ [ 1, 5, 4, 2, 3 ], 4, 1 ],
    [ [ 1, 1, 8, 9, 123, 43, 12, 5, 4, 2, 3 ], 2, 2 ],
    [ [ 1, 1, 8, 9, 123, 43, 12, 5, 4, 2, 3 ], 3, 4 ],
    [ [ 9, 8, 7, 6, 5, 4, 3, 2, 1 ], 6, 0 ],
    [ [ 9, 8, 7, 6, 5, 4, 3, 2, 1 ], 3, 6 ],
    [ [ 9, 8, 7, 6, 5, 4, 3, 2, 1 ], 2, 18 ],
    [ [ 9, 8, 7, 6, 5, 4, 3, 2, 1 ], 1, 38 ],
    [ [ 9, 8, 7, 6, 5, 4, 3, 2, 1 ], 8, 105 ],
    [ [ 2, 1, 1 ], 2, 1 ],
]
```

```js judger
function judge(a, x) {
    if (x === undefined) x = 1;
    for (var i = 0; i < x; i++) {
        a.unshift(a.pop());
    }
    return a;
}

const [ array, x ] = input;
assert(equal(
    solution.apply(null, input.concat()),
    judge.apply(null, input.concat()),
));
```

# task3 冒泡排序

冒泡排序是一种朴素的排序方法

具体来说，冒泡排序主要依靠"冒泡"这个操作来进行排序，冒泡是指，顺序遍历待排序的数组，对于每个元素，比较它和它后一个元素的大小，若相邻的元素为逆序，则交换这两个元素，然后再检查下一个元素。举个例子，`[ 1, 5, 4, 2, 3 ]`在进行一次冒泡后会变成`[ 1, 4, 2, 3, 5 ]`

不难证明(这个词是重点，要背诵)，对于长度为`n`的数组，进行`n`次这样的操作之后，一定会变成有序数列，请编写一个函数`solution`，用以计算当给定的待排序数组被进行`x`次操作后得到的数组

本题中排序按照从小到大的顺序进行，保证传入一定是`number`数组

```js init
/**
 * @param {number[]} array 要排序的数组
 * @param {number} x 进行冒泡的次数
 * @return {number[]} 进行x次排序之后的数组
 */
function solution(array, x) {

}

// judge-ignore
console.log(solution(input[0], input[1]));
```

```js input
[
    [ [ 1, 5, 4, 2, 3 ], 1 ],
    [ [ 1, 1, 8, 9, 123, 43, 12, 5, 4, 2, 3 ], 2 ],
    [ [ 1, 1, 8, 9, 123, 43, 12, 5, 4, 2, 3 ], 4 ],
    [ [ 9, 8, 7, 6, 5, 4, 3, 2, 1 ], 0 ],
    [ [ 9, 8, 7, 6, 5, 4, 3, 2, 1 ], 6 ],
    [ [ 9, 8, 7, 6, 5, 4, 3, 2, 1 ], 18 ],
    [ [ 9, 8, 7, 6, 5, 4, 3, 2, 1 ], 38 ],
    [ [ 9, 8, 7, 6, 5, 4, 3, 2, 1 ], 105 ],
    [ [ 2, 1, 1 ], 1 ],
    [ [], 1 ],
]
```

```js judger
function equal(a, b) {
    return JSON.stringify(a) === JSON.stringify(b);
}

function judge(array, x) {
    function bubble() {
        for (let i = 0; i < array.length-1; i++) {
            if (array[i] > array[i+1]) {
                const temp = array[i];
                array[i] = array[i+1];
                array[i+1] = temp;
            }
        }
    }
    for (let i = 0; i < x; i++) bubble();
    return array;
}

const [ array, x ] = input;
assert(equal(solution(array.concat(), x), judge(array.concat(), x)));
```

# task4 约瑟夫环

约瑟夫环是一个经典的编程问题

据说著名犹太历史学家Josephus有过以下的故事：在罗马人占领乔塔帕特后，39 个犹太人与Josephus及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。Josephus要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，于是逃过了这场死亡游戏。

请编写一个函数`solution`，用以计算当有`n`人参加，报到`m`的人自杀的情况下，最后一个自杀的人的初始序号（这样当你参加这个游戏的时候，就总是能逃过一劫了

> 提示：使用数组来模拟参与的人

测试数据保证`n > 1`, `m >= 1`

```js init
/**
 * @param {number} n 总人数
 * @param {number} m 报到m的人自杀 
 * @return {number} 一个数字，代表最后一个自杀的人的初始序号
 */
function solution(n, m) {

}

// judge-ignore
console.log(solution(input[0], input[1]));
```

```js input
[ [ 41, 3 ], [ 5, 3 ], [ 12, 77 ], [ 100, 2 ], [ 19, 3 ], [ 100, 101 ], [ 3, 1 ] ]
```

```js judger
function judge(n, m) {
    const loop = new Array(n).fill(true);
    let killed = 0, nw = -1;
    function getNext() {
        nw = loop.indexOf(true, nw+1);
        if (nw === -1) nw = loop.indexOf(true);
        return nw;
    }
    while (killed < n-1) {
        for (let count = 1; count <= m ; count++) {
            getNext();
        }
        loop[nw] = false;
        killed++;
    }
    return getNext()+1;
}
const [ n, m ] = input;
assert(judge(n, m) === solution(n, m));
```