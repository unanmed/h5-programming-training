# task1 创造Promise·一

在本节课中我们学习了`Promise`，这是一个神奇的概念，接下来我们通过三个题目制造一个简单的Promise。

<!-- 在本题中，你需要做出一个简单的`then`函数，它可以接收两个函数，第一个形如`Promise`的构造参数，第二个参数是一个回调函数，当第一个参数`resolve`时，请调用第二个参数 -->

在本题中，你需要做出类似`Promise`中`then`函数的机制，已经给出的函数`solution`有两个函数类型的参数：`resolver`和`then`。你需要向`resolver`传入一个函数`resolve`，当`resolve`触发时，请调用第二个参数`then`。

> 如果你忘记了 Promise 是啥，请再看一遍讲义

## 样例：

输入
```js
input = "123"
```

输出
```js
// res的值为：true
```

```js init
/**
 * @param {(resolve: () => void) => void} resolver 
 * @param {() => void} then 
 */
function solution(resolver, then) {
    
}

// @judge-ignore
function resolver(resolve) {
    resolve();
}
function then() {
    console.log("resolved");
}
solution(resolver, then);
await new Promise((res) => {
    setTimeout(res, 10);
});
```

```js input
[ 12, 323, 444, 433, 221, 32, 1032 ]
```

```js judger
let resolved = false;
// const _then = Promise.prototype.then;
try {
    await new Promise((res, rej) => {
        function resolver(resolve) {
            setTimeout(() => {
                if (resolved) {
                    rej("过早resolve");
                } else {
                    resolve();
                    setTimeout(() => {
                        if (!resolved) {
                            rej("过晚resolve");
                        } else {
                            res();
                        }
                    });
                }
            }, input);
        }
        function then() {
            resolved = true;
        }
        // Promise.prototype.then = () => {
        //     Promise.prototype.then = _then;
        //     rej("爪巴");
        // }
        solution(resolver, then);
        // Promise.prototype.then = _then;
    });
} catch(e) {
    assert(false, e.toString());
} finally {
    // Promise.prototype.then = _then;
}
```

# task2 创造Promise·二

我们继续创造Promise的旅程，在本节中，我们需要声明属于自己的Promise构造函数(和以往一样，名字为`solution`)，它构造出一个类似Promise的实例，并存储resolve出的值，允许多次调用then方法，并将这个值返回。

(本题不需要实现链式调用 即Promise.then().then()的形式

> 如果你无法理解题目意思，尝试阅读一下2-8的相关章节，以及给出的测试代码

```js init
/**
 * @param {(resolve: () => void) => void} resolver 
 */
function solution(resolver) {
    
}

// @judge-ignore
function resolver(resolve) {
    resolve("resolved");
}
new solution(resolver).then((v) => {
    console.log(v);
});
await new Promise((res) => {
    setTimeout(res, 10);
});
```

```js input
[ 12, 323, 444, 433, 221, 32, 1032 ]
```

```js judger
assert(solution !== Promise, "爪巴");
let resolved = 0;
try {
    await new Promise((res, rej) => {
        function resolver(resolve) {
            setTimeout(() => {
                if (resolved > 0) {
                    rej("过早resolve");
                } else {
                    resolve(input);
                    setTimeout(() => {
                        if (resolved < 2) {
                            rej("过晚resolve");
                        } else {
                            res();
                        }
                    });
                }
            }, input);
        }
        const thenable = new solution(resolver);
        if (thenable instanceof Promise) {
            rej("爪巴");
        }
        thenable.then((v) => {
            if (v !== input) {
                rej("then 获取的值错误");
            } else {
                resolved++;
                thenable.then((v) => {
                    resolved++;
                });
            }
        })
    });
} catch(e) {
    assert(false, e.toString());
} finally {
}
```

# task3 创造Promise·三

在第三步中，我们需要实现Promise剩下的一个重要的特性，即链式调用的`then`方法，你可以复用上一步的代码。

```js init
/**
 * @param {(resolve: () => void) => void} resolver 
 */
function solution(resolver) {
    
}

// @judge-ignore
function sleep(time) {
    return new Promise((res) => {
        setTimeout(() => {
            console.log("sleep: " + time);
            res();
        }, time);
    });
}
function resolver(resolve) {
    resolve();
}
new solution(resolver)
    .then(() => {
        console.log(Date.now());
        return new solution((res) => {
            sleep(10).then(res);
        })
    }).then(() => {
        console.log(Date.now());
    });
await sleep(100);
```

```js input
[ 12, 323, 444, 433, 221, 32, 1032 ]
```

```js judger
assert(solution !== Promise, "爪巴");
let resolved = 0;
// const _then = Promise.prototype.then;
try {
    await new Promise((res, rej) => {
        function resolver(resolve) {
            setTimeout(() => {
                if (resolved > 0) {
                    rej("过早resolve");
                } else {
                    resolve(input);
                    setTimeout(() => {
                        if (resolved != 1) {
                            rej("链式调用失败");
                        } else {
                            res();
                        }
                    });
                }
            }, input);
        }
        // Promise.prototype.then = () => {
        //     rej("爪巴");
        // }
        const thenable = new solution(resolver);
        if (thenable instanceof Promise) {
            rej("爪巴");
        }
        thenable
            .then(() => {
                resolved++;
                return new solution((r2) => {
                    setTimeout(() => {
                        r2();
                        setTimeout(() => {
                            if (resolved != 2) {
                                rej("链式调用失败");
                            } else {
                                res();
                            }
                        });
                    }, 100);
                });
            }).then(() => {
                resolved++;
            })
        // Promise.prototype.then = _then;
    });
} catch(e) {
    assert(false, e.toString());
} finally {
    // Promise.prototype.then = _then;
}
```

# task4 创造Promise.all

在本节课中我们学习了`Promise.all`， 这个函数接收一个Promise数组，组合成一个Promise，使得其在所有Promise完成后完成。

现在，你需要编写一个具有相同功能的函数

```js init
/**
 * @param {Promise[]} promises 
 * @return {Promise} 
 */
function solution(promises) {
    
}

// @judge-ignore
function sleep(time) {
    return new Promise((res) => {
        setTimeout(() => {
            console.log("sleep: " + time);
            res();
        }, time);
    });
}
solution(input.map((e) => sleep(e))).then(() => {
    console.log("all resolved");
});
```

```js input
[ [100, 1000], [], [0], [123,3134,432], [12,323,444,433,221,32,1032] ]
```

```js judger
let count = 0, target = input.length;
let resolved = false;
function sleep(time) {
    return new Promise((res) => {
        setTimeout(() => {
            count++;
            res();
        }, time);
    });
}
const tasks = input.map((e) => sleep(e));
const all = Promise.all;
try {
    await new Promise((res, rej) => {
        Promise.all = () => {
            rej("爪巴");
        }
        solution(tasks).then(() => {
            resolved = true;
            if (count !== target) {
                rej("过早resolve");
            } else {
                res();
            }
        });
        Promise.all = all;
        Promise.all(tasks).then(() => {
            setTimeout(() => {
                if (!resolved) {
                    rej("过晚resolve");
                }
            });
        });
    });
} catch(e) {
    assert(false, e);
} finally {
    Promise.all = all;
}
```
