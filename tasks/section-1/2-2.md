## task1 神必数列

设某个数列的递推公式为 `f(x) = f(x-1) - f(x-2) + f(x-3) * 2` 且 `f(0) = 1`, `f(1) = 1`, `f(2) = 1`, 请编写一个名为`solution`的函数，使其能接收一个数字`x`，返回`f(x)`的值

## 样例：

输入
```js
x = 9
```

输出
```js
10
```

```js init
/**
 * @param {number} x 项数
 * @return {number} f(x)的值
 */
function solution(x) {

}

// @judge-ignore
console.log(solution(input));
```

```js input
[ 1, 3, 9, 12, 17, 23 ];
```

```js judger
function judge(x) {
    if (x <= 2) return 1;
    return judge(x-1) - judge(x-2) + judge(x-3) * 2;
}
assert(judge(input) === solution(input), "答案错误");
```

## task2 自定义比较器的去重

请编写一个函数`solution`，根据给出的比较器对传入的参数进行去重，并返回去重后的元素数量。比较器将作为函数的第一个参数传入（比较器不计入要去重的参数内），比较器是一个函数，它能够接受两个参数`a`, `b`，若返回值为`true`，则认为`a`和`b`是重复的元素，否则，则认为a和b不同。

去重是指，对于一组元素，将其中重复的元素去除，直到剩下的元素两两不相同，重复的标准只看compare(a, b)的结果。

保证传入的比较函数满足交换律，传递性和反传递性，即总有`compare(a, b) === compare(b, a)`，以及若 `compare(a, b) && compare(b, c)` 返回`true` 则 `compare(a, c)` 也为 `true`

## 样例：

输入
```js
compare = function (a, b) { return a == b }
rest = [1, 1, 2, "2", 3] // solution(compare, ...rest)相当于solution(compare, 1, 1, 2, "2", 3)
```

输出
```js
3
// [1, 1, 2, 3, "2"] 1和1重复 删除后数组为[1, 2, 3, "2]
// 2 == "2" 重复 删除后数组为[1, 2, 3] 输出数组长度3
```

```js init
/**
 * @template T
 * @param {(a: T, b: T) => boolean} compare 比较函数
 * @param {...T} var_args 传入的值
 *
 * @return {number} 不同数的数量
 */
function solution(compare) {

}

// @judge-ignore
const [ compare, ...rest ] = input;
console.log(solution(eval(compare), ...rest));
```

```js input
[
    [ "(a, b) => a === b", 1, 1, 2, "2" ],
    [ "(a, b) => a == b", 1, 1, 2, "2" ],
    [ "(a, b) => (a % 2 === b % 2)", 1, 1, 2, 7, 8 ],
]
```

```js judger
function judge(compare, ...rest) {
    return rest.filter((e, i, arr) => {
        for (var j = 0; j < i; j++) {
            if (compare(arr[j], e)) return false;
        }
        return true;
    }).length;
}
const [ compare, ...rest ] = input;
assert(solution(eval(compare), ...rest) === judge(eval(compare), ...rest));
```

## task3 作弊

我们将在第二章结束之后展开阶段性的大检测（是真的吗？），然而，神必的大脑升级人并没有认真学习，而是在设法与人py，具体来说，他总是有办法在评测之前得到正确答案，因此，他可以临场构造出可以返回正确答案的程序，，，不过，他是如此的懒惰以至于他不想自己写这个程序。

因此，他希望你写一个函数`solution`，接收一个评测函数`judge`，以及他py得到的答案`answer`，评测函数需要一个返回`answer`的函数做为参数，评测函数将会调用这个函数并检查你的答案是否正确，请定义一个函数并让它返回预先已经知道的答案`answer`，并将这个函数做为评测函数的参数，之后，在`solution`中运行评测函数。

## 样例：

输入
```js
judge = (getAnswer) => {
   if (getAnswer() === 1919810) pass();
}
answer = 1919810
]
```

输出
```js
// 你pass了
```

```js init
/**
 * @template T
 * @param {(solution: () => T) => void} judge 评测函数
 * @param {T} answer 答案
 */
function solution(judge, answer) {

}

```

```js input
[ "hello,world", 123, null, [ 5 ] ]
```

```js judger
escape = true;
solution((answer) => {
    assert(answer() === input, "回答错误");
    escape = false;
}, input);
assert(!escape, "没有做出回答")
```

## task4 函数合成

在函数式编程中，利用函数合成来复用逻辑非常流行，请你编写一个函数`solution`，其接收两个判断函数（即接收一个值，并返回一个布尔值的函数），并返回一个新的判断函数，使其为这两个函数的与函数（也就是说，只有当两个判断函数都返回true时才返回true，否则返回false

## 样例：

输入
```js
input = [0.3, 0.5]
fb = function(v) { return input[0] > v }
fb = function(v) { return input[1] > v }
v = 0.4;
```

输出
```js
false
// 0.3<0.4 false&&true 返回false
```

```js init
/**
 * @template T
 * @param {(value: T) => boolean} fa 判断函数a
 * @param {(value: T) => boolean} fb 判断函数b
 * 
 * @return {(value: T) => boolean}
 */
function solution(fa, fb) {

}

// @judge-ignore
console.log(solution((v) => true, (v) => false)(null));
```

```js input
[ [ 0.3, 0.5 ], [ 0.8, 0.7 ], [ 0.3, 0.1 ], [ 0.1, 0.9 ], [ 0, 1 ], [ 1, 1 ], [ 0.15, 0.35] ]
```

```js judger
const fa = (v) => input[0] > v; 
const fb = (v) => input[1] < v;

const target = Math.random();
assert(solution(fa, fb)(target) === (fa(target) && fb(target)));
```
